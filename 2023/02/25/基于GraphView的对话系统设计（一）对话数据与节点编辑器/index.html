<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基于GraphView的对话系统设计（一）对话数据与节点编辑器 | 游戏开发小地方</title><meta name="author" content="Bigotry0,lim.young@foxmail.com"><meta name="copyright" content="Bigotry0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对话系统特点 使用节点编辑器编辑对话，便于策划等非程序岗参与项目开发 拓展性强，可自定义节点，方便根据项目需求进行拓展 使用逻辑简单、直观，无需进行大量配置 对话数据持久化储存，且带增删管理 节点可进行逻辑控制   系统实现首先，我们设计一下对话系统进行的结构分层，在该对话系统中，我们将其分为节点编辑器、对话数据，对话逻辑处理系统三个部分。我们可以用下图来表示：    graph LR A[Ed">
<meta property="og:type" content="article">
<meta property="og:title" content="基于GraphView的对话系统设计（一）对话数据与节点编辑器">
<meta property="og:url" content="https://bigotry0.github.io/2023/02/25/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/index.html">
<meta property="og:site_name" content="游戏开发小地方">
<meta property="og:description" content="对话系统特点 使用节点编辑器编辑对话，便于策划等非程序岗参与项目开发 拓展性强，可自定义节点，方便根据项目需求进行拓展 使用逻辑简单、直观，无需进行大量配置 对话数据持久化储存，且带增删管理 节点可进行逻辑控制   系统实现首先，我们设计一下对话系统进行的结构分层，在该对话系统中，我们将其分为节点编辑器、对话数据，对话逻辑处理系统三个部分。我们可以用下图来表示：    graph LR A[Ed">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bigotry0.github.io/img/posts_cover/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8.png">
<meta property="article:published_time" content="2023-02-25T06:35:34.000Z">
<meta property="article:modified_time" content="2023-05-11T17:06:19.978Z">
<meta property="article:author" content="Bigotry0">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bigotry0.github.io/img/posts_cover/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://bigotry0.github.io/2023/02/25/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于GraphView的对话系统设计（一）对话数据与节点编辑器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-12 01:06:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/Avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/posts_cover/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8.png')"><nav id="nav"><span id="blog-info"><a href="/" title="游戏开发小地方"><span class="site-name">游戏开发小地方</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于GraphView的对话系统设计（一）对话数据与节点编辑器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-25T06:35:34.000Z" title="发表于 2023-02-25 14:35:34">2023-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-11T17:06:19.978Z" title="更新于 2023-05-12 01:06:19">2023-05-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于GraphView的对话系统设计（一）对话数据与节点编辑器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<h2 id="对话系统特点"><a href="#对话系统特点" class="headerlink" title="对话系统特点"></a>对话系统特点</h2><ul>
<li>使用节点编辑器编辑对话，便于策划等非程序岗参与项目开发</li>
<li>拓展性强，可自定义节点，方便根据项目需求进行拓展</li>
<li>使用逻辑简单、直观，无需进行大量配置</li>
<li>对话数据持久化储存，且带增删管理</li>
<li>节点可进行逻辑控制</li>
</ul>
</blockquote>
<h2 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h2><p>首先，我们设计一下对话系统进行的结构分层，在该对话系统中，我们将其分为节点编辑器、对话数据，对话逻辑处理系统三个部分。我们可以用下图来表示：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph LR
A[Editor] --&gt; B[Data]
B --&gt; A
B --&gt; D[System]
  </pre></div>
<p>对话数据采用 Scriptableobject 来实现编辑模式下的数据可变性和运行模式下的数据可持久性，节点编辑器于编辑器下运行，为对话数据文件唯一编辑方式。</p>
<h2 id="编辑器部分"><a href="#编辑器部分" class="headerlink" title="编辑器部分"></a>编辑器部分</h2><p>对于该节点式编辑器的制作，我们这里使用的是 Unity 自带的 GraphView API 来进行开发，GraphView 的相关中文资料较少，在开发的过程中也是踩到了不少坑。<br>为了创建一个编辑器窗口，我们打开资源菜单，选择创建，选择UI工具箱（UI UIToolkit），选择编辑器窗口，会出现以下画面：</p>
<p><img src="https://img-blog.csdnimg.cn/043b2dcd416847628392fdbed2e96180.png" alt="UI UIToolkit创建菜单"></p>
<p>我们可以将其命名为DialogGraphWindow，点击创建，Unity会自动为我们创建文件。</p>
<p><img src="https://img-blog.csdnimg.cn/283cd0eb141c4784a36c04cfefc25dff.png" alt="命名"></p>
<p>创建完成后，首先是编辑器的主体部分，双击创建好的DialogGraphWindow.uxml文件，Unity会自动打开 UIToolkit 中的 UIBuilder，在该窗口中，我们可以自定义我们的窗口布局，下面是本对话系统的UI布局：</p>
<p><img src="https://img-blog.csdnimg.cn/857f7810e67a48bd89b89671af5c2bd7.png#pic_center" alt="简易的布局"><br>布局结构很简单，值得注意的是，我们需要在面板的Hierarchy窗口中点击.uxml文件，然后在Inspector窗口中勾选Editor Extension Authoring选项，这样我们才可以在编辑模式下使用编辑器UI组件，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/750d7c8281bd44909f111a9e8379a782.png#pic_center" alt="勾选Editor Extension Authoring"></p>
<p>其中的DialogGraphView组件，并不是在Stander窗口里创建。我们没有在 Standard中看到这一 UI 组件，这是因为 GraphView 组件是需要我们自己手动创建的，新建一个脚本，让他继承 GraphView，并进行该自定义 UI 组件的配置，代码如下：</p>
<pre><code class="C#">#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace DialogueSystem
&#123;
    public class DialogGraphView : GraphView
    &#123;
        public new class UxmlFactory : UxmlFactory&lt;DialogGraphView, GraphView.UxmlTraits&gt;
        &#123;
        &#125;

        public DialogGraphView()
        &#123;
            //增加格子背景
            Insert(0, new GridBackground());

            //增加内容缩放，拖动，拖拽，框选控制器
            this.AddManipulator(new ContentZoomer());
            this.AddManipulator(new ContentDragger());
            this.AddManipulator(new SelectionDragger());
            //框选 bug
            //大坑！控制器之间存在优先级
            //这就是为什么框选控制器放在选择拖放节点控制器之前会导致节点无法移动
            //因为框选的优先级更高
            this.AddManipulator(new RectangleSelector());

            var styleSheet =
                AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;(
                    //此处填你项目对应 uss 文件路径
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogueTreeView.uss&quot;);
            styleSheets.Add(styleSheet);

            //初始化 treedata 布局
            if (treeData != null)
            &#123;
                contentViewContainer.transform.position = treeData.GraphViewData.Position;
                contentViewContainer.transform.scale = treeData.GraphViewData.Scale;
            &#125;
        &#125;
&#125;
#endif
</code></pre>
<p>打开DialogGraphWindow.cs脚本，修改脚本如下：</p>
<pre><code class="C#">#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.UIElements;

namespace LFramework.AI.Kit.DialogueSystem
&#123;
    public class DialogGraphWindow : EditorWindow
    &#123;
        [MenuItem(&quot;Window/UI Toolkit/DialogueView&quot;)]
        public static void ShowExample()
        &#123;
            DialogueView wnd = GetWindow&lt;DialogueView&gt;();
            wnd.titleContent = new GUIContent(&quot;DialogueView&quot;);
        &#125;

        private DialogGraphView _graphView = null;

        public static void CloseEditorWindow()
        &#123;
            DialogGraphWindow wnd = GetWindow&lt;DialogGraphWindow&gt;();
            wnd.Close();
        &#125;

        public void CreateGUI()
        &#123;
            var visualTree =
                AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogGraphWindow.uxml&quot;);
            visualTree.CloneTree(rootVisualElement);

            _graphView = rootVisualElement.Q&lt;DialogGraphView&gt;(&quot;DialogGraphView&quot;);

            var saveButton = rootVisualElement.Q&lt;ToolbarButton&gt;(&quot;SaveButton&quot;);
            saveButton.clicked += OnSaveButtonClicked;
        &#125;

        //保存资源文件
        private void OnSaveButtonClicked()
        &#123;
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        &#125;

        private void OnDestroy()
        &#123;
            AssetDatabase.SaveAssets();
        &#125;
    &#125;
&#125;
#endif
</code></pre>
<p>现在我们回到 Untiy，重新编译后，点击 project 按钮，就可以看到我们刚刚创建好的组件。拖拽组件到窗口中，或许屏幕上并没有变化。选中 GraphView 组件，修改其 grow 值为 1，现在我们应该就能看到我们的 GraphView 了。完成之后，我们来开始创建我们的对话节点。</p>
<h2 id="对话节点"><a href="#对话节点" class="headerlink" title="对话节点"></a>对话节点</h2><p>对于每一个对话节点，我们都可以将其分为 Data 层和 View 层。在View 层中，我们只是对我们的节点数据进行可视化处理，在 View 层中，我们也能对对话节点进行编辑，编辑的目标就是我们的 Data 层。Data 层才是我们对话数据的关键部分，保存节点包含的各种信息。<br>在该对话系统中，我们采用了 Scriptableobject 来进行数据的存储，使用 Scriptableobject 可以实现在编辑器中的数据持久化，而且还能达成数据的可复用性。<br>所以首先，我们需要一个用来管理所有对话节点数据的数据结构类，创建一个 DialogTree 类，代码如下：</p>
<pre><code class="C#">using System;
using System.Collections.Generic;
using LFramework.AI.Kit.DialogueSystem;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace DialogueSystem
&#123;
    [CreateAssetMenu(menuName = &quot;Create new DialogTreeData&quot;,fileName = &quot;DialogTreeData&quot;)]
    public class DialogTree : ScriptableObject
    &#123;
        public DialogNodeDataBase StartNodeData = null;

        public List&lt;DialogNodeDataBase&gt; ChildNodeDataList = new List&lt;DialogNodeDataBase&gt;();

        // 用来储存节点视图信息
        [Serializable]
        public class ViewData
        &#123;
            public Vector3 Position;
            public Vector3 Scale = new Vector3(1, 1, 1);
        &#125;

        public ViewData GraphViewData = new ViewData();
    &#125;
&#125;
</code></pre>
<p>在这里，我们定义一个头结点对象和一个子节点列表，每个对话树 Scriptableobject 都记录着他所管理的所有对话节点的信息，所以接下来，我们来定义节点数据的基类 DialogDataBase，代码如下:</p>
<pre><code class="C#">using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

namespace DialogueSystem
&#123;
    public abstract class DialogNodeDataBase : ScriptableObject
    &#123;
        /// &lt;summary&gt;
        /// 节点坐标
        /// &lt;/summary&gt;
        [HideInInspector] public Vector2 Position = Vector2.zero;

        [HideInInspector] public string Path;

        /// &lt;summary&gt;
        /// 节点类型
        /// &lt;/summary&gt;
        public abstract NodeType NodeType &#123; get; &#125;

        protected DialogNodeDataBase()
        &#123;
        &#125;

        private void OnValidate()
        &#123;
#if UNITY_EDITOR
            AssetDatabase.SaveAssets();
#endif
        &#125;

        public List&lt;string&gt; OutputItems = new List&lt;string&gt;();

        public List&lt;DialogNodeDataBase&gt; ChildNode = new List&lt;DialogNodeDataBase&gt;();
    &#125;
&#125;
</code></pre>
<p>在这个对话节点基类中，我们定义了所有节点的通用属性，其中最重要的是两个列表，一个是用于储存节点输出信息的 OutputItems 列表，他可以用于储存对话数据，也可以根据不同的需求，储存节点所需的字符串信息。另一个ChildNode列表用于储存对话节点间的关系，包含了该节点的所有子节点对象，这是这套对话系统的关键。</p>
<p>在读取数据时，根据对话树的头节点，按照节点连线规则一直往下选择下一个对话节点，重复读取直至对话节点进行至 End 节点结束。这样的逻辑有点像是链表。</p>
<p>除此之外，节点中的 NodeType 属性也是对话系统的关键部分，在读取一个节点时，通过检测节点的类型，我们可以使用不同的方式来处理节点，以实现节点的逻辑控制，这部分我们将在后面构建对话系统的数据处理部分详细介绍。</p>
<p>所以，接下来我们来创建两个关键的对话节点，StartNode 跟 EndNode。在创建节点之前，我们先创建一个新的 C#脚本，在脚本中创建一个 NodeType 枚举类，代码如下：</p>
<pre><code class="C#">namespace DialogueSystem
&#123;
    public enum NodeType
    &#123;
        Start,
        End,
    &#125;
&#125;
</code></pre>
<p>接下来是我们的两个对话节点，代码如下；<br>StartNode：</p>
<pre><code class="C#">namespace DialogueSystem
&#123;
    public class StartNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.Start;
    &#125;
&#125;
</code></pre>
<p>EndNode：</p>
<pre><code class="C#">namespace DialogueSystem
&#123;
    public class EndNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.End;
    &#125;
&#125;
</code></pre>
<p>这两个都继承了我们的 DialogDataBase 基类，在这里我们只需要指定他们的类型即可。</p>
<p>创建好节点的 Data 层后，我们来实现对话节点的 View 层，创建一个 NodeViewBase 基类，代码如下：</p>
<pre><code class="C#">#if UNITY_EDITOR
using System;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DialogueSystem
&#123;
    public abstract class NodeViewBase : Node
    &#123;
        public Action&lt;NodeViewBase&gt; OnNodeSelected;
        
        public string GUID;

        //对话数据
        public DialogNodeDataBase DialogNodeData = null;

        public NodeViewBase(DialogNodeDataBase dialogNodeData) : base()
        &#123;
            GUID = Guid.NewGuid().ToString();
            DialogNodeData = dialogNodeData;
            //大坑，新版本unity不自动在磁盘上应用资源更新，必须先给目标物体打上Dirty标记
            EditorUtility.SetDirty(DialogNodeData);
        &#125;

        public Port GetPortForNode(NodeViewBase node, Direction portDirection,
            Port.Capacity capacity = Port.Capacity.Single)
        &#123;
            return node.InstantiatePort(Orientation.Horizontal, portDirection, capacity, typeof(bool));
        &#125;

        public override void OnSelected()
        &#123;
            base.OnSelected();
            OnNodeSelected?.Invoke(this);
        &#125;
    &#125;
&#125;
#endif
</code></pre>
<p>view 层我们主要使用了 GraphView 的 Node 基类，我们的基类继承了 Node，这样可以使我们在 GraphView 中创建出自定义的节点UI，上面的代码我们重写了OnSelected方法，将节点被选中的事件发送出去。</p>
<p>按照我们的设计，开始节点只有一个输出口，且接口只能连接一个子节点，也就是说，StartNode拥有一个单一输出口。而EndNode则可以接受多个输入，但他不能有输出口，因为EndNode节点表示的是对话树的终止处，所以EndNode将有一个支持多输入的输入口，我们来实现这两个节点，代码如下：<br>StartNode：</p>
<pre><code class="C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DialogueSystem
&#123;
    public class StartNodeView : NodeViewBase
    &#123;
        public StartNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;Start&quot;;
            
            Port output = GetPortForNode(this, Direction.Output, Port.Capacity.Single);
            output.portName = &quot;output&quot;;
            output.name = &quot;0&quot;;
            
            output.portColor = Color.green;
            outputContainer.Add(output);
            
            if (DialogNodeData.ChildNode.Count &lt; 1)
            &#123;
                DialogNodeData.ChildNode.Add(null);
            &#125;
        &#125;
    &#125;
&#125;
#endif
</code></pre>
<p>EndNode：</p>
<pre><code class="C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DialogueSystem
&#123;
    public class EndNodeView : NodeViewBase
    &#123;
        public EndNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;End&quot;;
            
            Port input = GetPortForNode(this, Direction.Input, Port.Capacity.Multi);
            input.portName = &quot;input&quot;;
            input.portColor = Color.gray;
            
            inputContainer.Add(input);
        &#125;
    &#125;
&#125;
#endif
</code></pre>
<p>很简单，我们为我们的节点创建了上面所描述类型的Port，并把他们分别添加进InputContainner和OutputContainner中。接下来，我们回到GraphView脚本，我们来拓展右键菜单，让我们可以创建出我们的节点。代码如下：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 菜单点击时鼠标位置
        /// &lt;/summary&gt;
        private Vector2 clickPosition;

        /// &lt;summary&gt;
        /// 节点点击事件
        /// &lt;/summary&gt;
        public Action&lt;NodeViewBase&gt; OnNodeSelected;

        public static DialogTree treeData = null;

        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        &#123;
            base.BuildContextualMenu(evt);
            Debug.Log(evt.mousePosition);

            //将鼠标世界坐标转为视图本地坐标
            clickPosition = contentViewContainer.WorldToLocal(evt.mousePosition);

            evt.menu.AppendAction(&quot;Create StartNode&quot;, x =&gt;
            &#123;
                var dialogNodeData = ScriptableObject.CreateInstance&lt;StartNodeData&gt;();
                var nodeView = new StartNodeView(dialogNodeData)
                &#123;
                    //设置点击事件
                    OnNodeSelected = OnNodeSelected
                &#125;;
                nodeView.SetPosition(new Rect(clickPosition, nodeView.GetPosition().size));
                this.AddElement(nodeView);
            &#125;);

            evt.menu.AppendAction(&quot;Create EndNode&quot;, x =&gt;
            &#123;
                var dialogNodeData = ScriptableObject.CreateInstance&lt;EndNodeData&gt;();
                var nodeView = new EndNodeView(dialogNodeData)
                &#123;
                    //设置点击事件
                    OnNodeSelected = OnNodeSelected
                &#125;;
                nodeView.SetPosition(new Rect(clickPosition, nodeView.GetPosition().size));
                this.AddElement(nodeView);
            &#125;);
        &#125;
</code></pre>
<p>如果我们现在回到Unity打开我们节点编辑器，右键创建节点，我们会看到两个节点都成功的创建了出来。可当我们尝试连接节点时，我们会发现所有的节点端口都变灰了，我们无法连接任何节点。这是因为我们还没有配置节点的连接规则，重新回到GraphView脚本，Override GetCompatiblePorts函数。代码如下：</p>
<pre><code class="C#">        //节点链接规则
        public override List&lt;Port&gt; GetCompatiblePorts(Port startPort, NodeAdapter nodeAdapter)
        &#123;
            return ports.ToList().Where(endPort =&gt;
                endPort.direction != startPort.direction &amp;&amp;
                endPort.node != startPort.node &amp;&amp;
                endPort.portType == startPort.portType
            ).ToList();
        &#125;
</code></pre>
<p>连接规则很简单，即节点自己不能连接自己，节点接口方向不能相同，且只有相同类型的端口可以互相连接。在我们这个系统中，节点间的连线仅表示数据流向，不涉及数据类型，项目里所有节点接口的类型都被我统一为bool类型。</p>
<p>现在我们回到Unity，打开节点编辑器，创建节点，连接，这次的效果就符合我们的预期了。</p>
<p><img src="https://img-blog.csdnimg.cn/b86f50bdc300473c80fb55ae09f92dc2.png#pic_center" alt="在这里插入图片描述"><br>现在我们完成的是节点UI的显示，也就是说，现阶段的节点是没有任何实际功能的。我们来继续完善Start跟End节点，使他们与他们对应的Data层对象相关联。</p>
<p>首先是创建节点的部分，我们打开GraphView脚本，增加一个CreateNode方法。代码如下：</p>
<pre><code class="C#">        //确保目录存在
        private void MakeSureTheFolder()
        &#123;
            //TODO：做成可自行设置的对话资源文件部署
            if (!AssetDatabase.IsValidFolder(&quot;Assets/DialogueData/NodeData&quot;))
            &#123;
                AssetDatabase.CreateFolder(&quot;Assets&quot;, &quot;DialogueData&quot;);
                AssetDatabase.CreateFolder(&quot;Assets/DialogueData&quot;, &quot;NodeData&quot;);
            &#125;
        &#125;

        /// &lt;summary&gt;
        /// 新建节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
        private void CreateNode(NodeType type, Vector2 position = default)
        &#123;
            if (treeData == null)
            &#123;
                return;
            &#125;

            MakeSureTheFolder();
            NodeViewBase nodeView = null;

            //创建节点的核心，新增的节点需要在这里进行创建方式的添加
            switch (type)
            &#123;
                case NodeType.Start:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;StartNodeData&gt;();
                    dialogNodeData.Path = $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new StartNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;EndNodeData&gt;();
                    dialogNodeData.Path = $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new EndNodeView(dialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            //添加节点被选择事件
            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(position, nodeView.GetPosition().size));

            this.AddElement(nodeView);
        &#125;
</code></pre>
<p>我们在创建节点UI之前，都会创建一个对应节点的DialogNodeDataBase对象，并将其保存为asset文件。而在View中，在创建出节点UI时，将持有刚创建的DialogNodeDataBase对象。<br>现在我们创建节点就可以直接使用CreateNode函数了，我们可以修改右键菜单，使用新的创建节点方法，修改GraphView中代码如下：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 右键菜单
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;
        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        &#123;
            base.BuildContextualMenu(evt);
            Debug.Log(evt.mousePosition);

            //将鼠标世界坐标转为视图本地坐标
            clickPosition = contentViewContainer.WorldToLocal(evt.mousePosition);

            if (treeData.StartNodeData == null)
            &#123;
                evt.menu.AppendAction(&quot;Create StartNode&quot;, x =&gt; &#123; CreateNode(NodeType.Start, clickPosition); &#125;);
            &#125;

            evt.menu.AppendAction(&quot;Create EndNode&quot;, x =&gt; &#123; CreateNode(NodeType.End, clickPosition); &#125;);
        &#125;
</code></pre>
<p>到这里，我们的单个节点才总算是相对完整了，但是，我们还没有处理节点与节点间的数据连接，在该对话系统的设计中，节点与节点间的连接表示的是对话节点数据的读取顺序，Unity在GraphView中提供了一个graphViewChanged事件，该事件可以监听GraphView中的各种变化，包括节点的移动，连线的创建、删除等，我们打开GraphView脚本，增加以下代码：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 节点图变化事件
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;graphviewchange&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private GraphViewChange OnGraphViewChanged(GraphViewChange graphviewchange)
        &#123;
            if (graphviewchange.elementsToRemove != null)
            &#123;
                graphviewchange.elementsToRemove.ForEach(elem =&gt;
                &#123;
                    //连线删除
                    else if (elem is Edge edge)
                    &#123;
                        NodeViewBase parentNodeView = edge.output.node as NodeViewBase;
                        NodeViewBase childNodeView = edge.input.node as NodeViewBase;
                        if (parentNodeView != null &amp;&amp; childNodeView != null)
                        &#123;
                            if (int.TryParse(edge.output.name, out int index))
                            &#123;
                                parentNodeView.DialogNodeData.ChildNode[index] = null;
                            &#125;
                            else
                            &#123;
                                Debug.LogError(&quot;Node.name(string) to int fail&quot;);
                            &#125;
                        &#125;
                    &#125;
                &#125;);
            &#125;

            if (graphviewchange.edgesToCreate != null)
            &#123;
                //创建连线
                graphviewchange.edgesToCreate.ForEach(edge =&gt;
                &#123;
                    NodeViewBase parentNodeView = edge.output.node as NodeViewBase;
                    NodeViewBase childNodeView = edge.input.node as NodeViewBase;

                    if (parentNodeView != null &amp;&amp; childNodeView != null)
                    &#123;
                        if (int.TryParse(edge.output.name, out int index))
                        &#123;
                            parentNodeView.DialogNodeData.ChildNode[index] = childNodeView.DialogNodeData;
                        &#125;
                        else
                        &#123;
                            Debug.LogError(&quot;Node.name(string) to int fail&quot;);
                        &#125;
                    &#125;
                &#125;);
            &#125;

            return graphviewchange;
        &#125;
</code></pre>
<p>然后在初始化GraphView的时候往graphViewChanged事件添加我们的OnGraphViewChanged方法，在GraphView脚本中的DialogGraphView()方法添加以下代码即可。代码如下：</p>
<pre><code class="C#">            //监听graphView变化事件
            graphViewChanged += OnGraphViewChanged;
</code></pre>
<p>创建连线时，我们获取一下该连线的两端节点，并将输入口的节点对应的DialogNodeDataBase对象添加进输出口节点的DialogNodeDataBase的子对象列表中。当然，在连线删除的时候，我们也应该同步删除父节点子对象列表中的对应子节点。</p>
<p>现在，节点间已经能够在数据层面上进行连接了，但我们还有一件重要的事情没有做。如果将节点编辑器关闭后再打开，我们会发现节点编辑器回到了初始状态，我们的节点数据并没有在节点图中展示。所以接下来我们来实现一下节点图的保存与解析。</p>
<h2 id="节点图的保存与解析"><a href="#节点图的保存与解析" class="headerlink" title="节点图的保存与解析"></a>节点图的保存与解析</h2><p>我们在节点编辑器里编辑的节点，最终保存为一个个节点数据文件，还记得我们当时创建的DialogTree类吗？DialogTree就是专门用来管理节点数据的数据结构类，我们修改CreateNode代码，在创建节点的时候将节点对象添加进DialogTree中。打开GraphView脚本，在CreateNode函数末尾加入代码，代码如下：</p>
<pre><code class="C#">            //对Start节点做个特判
            if (nodeView.DialogNodeData.NodeType == NodeType.Start)
            &#123;
                treeData.StartNodeData = nodeView.DialogNodeData;
            &#125;
            else
            &#123;
                treeData.ChildNodeDataList.Add(nodeView.DialogNodeData);
            &#125;
</code></pre>
<p>在一个DialogTree中，我们只能有一个StartNode，并且StartNode对象是作为一个特别对待的节点储存在DialogTree中的StartNodeData变量中。现在我们可以更改一下编辑器的打开逻辑，不再是通过菜单栏打开节点编辑器，而是改成打开DialogTree对象的asset文间来打开节点编辑器，这样也可以在打开时获取到打开的DialogTree对象，从而对该DialogTree与GraphView进行关联。打开DialogGraphWindow脚本，编辑代码如下：</p>
<pre><code class="C#">#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.UIElements;

namespace LFramework.AI.Kit.DialogueSystem
&#123;
    public class DialogGraphWindow : EditorWindow
    &#123;
        // 移除原先的打开方式
        // [MenuItem(&quot;Window/UI Toolkit/DialogueView&quot;)]
        // public static void ShowExample()
        // &#123;
        //
        //     DialogueView wnd = GetWindow&lt;DialogueView&gt;();
        //     wnd.titleContent = new GUIContent(&quot;DialogueView&quot;);
        // &#125;

        private DialogGraphView _graphView = null;

        // 打开DialogTree资源时触发
        [OnOpenAsset(1)]
        public static bool OnOpenAsssets(int id, int line)
        &#123;
            if (EditorUtility.InstanceIDToObject(id) is DialogTree tree)
            &#123;
                //打开不同DialogTree文件
                if (DialogGraphView.treeData != tree)
                &#123;
                    Debug.Log(DialogGraphView.treeData);
                    DialogGraphView.treeData = tree;

                    //判断窗口是否打开
                    if (HasOpenInstances&lt;DialogGraphWindow&gt;())
                    &#123;
                        CloseEditorWindow();
                    &#125;

                    //大大大大大坑！新版本unity不自动在磁盘上应用资源更新，必须先给目标物体打上Dirty标记
                    EditorUtility.SetDirty(tree);
                &#125;

                DialogGraphWindow wnd = GetWindow&lt;DialogGraphWindow&gt;();
                wnd.titleContent = new GUIContent(&quot;DialogueView&quot;);
                
                return true;
            &#125;
            return false;
        &#125;

        public static void CloseEditorWindow()
        &#123;
            DialogGraphWindow wnd = GetWindow&lt;DialogGraphWindow&gt;();
            wnd.Close();
        &#125;

        public void CreateGUI()
        &#123;
            var visualTree =
                AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogGraphWindow.uxml&quot;);
            visualTree.CloneTree(rootVisualElement);

            _graphView = rootVisualElement.Q&lt;DialogGraphView&gt;(&quot;DialogGraphView&quot;);

            _inspectorView = rootVisualElement.Q&lt;InspectorView&gt;(&quot;InspectorView&quot;);

            var saveButton = rootVisualElement.Q&lt;ToolbarButton&gt;(&quot;SaveButton&quot;);
            saveButton.clicked += OnSaveButtonClicked;
        &#125;

        //保存资源文件
        private void OnSaveButtonClicked()
        &#123;
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            Debug.Log(&quot;Save&quot;);
        &#125;

        private void OnDestroy()
        &#123;
            //对象销毁之前记得保存一下，保险
            AssetDatabase.SaveAssets();
        &#125;
    &#125;
&#125;
#endif
</code></pre>
<p>打开GraphView脚本，添加一个静态变量用于储存当前DialogTree。代码如下：</p>
<pre><code class="C#">        public static DialogTree treeData = null;
</code></pre>
<p>回到Unity，双击DialogTree.asset文件，可以看到，节点编辑器被成功打开。但是，我们还是没有在编辑器里看到任何节点，那是因为我们还没有对DialogTree中的数据进行处理。既然在DialogTree里已经有了我们整个对话树的节点数据，那我们是不是就可以在编辑器打开的时候，读取DialogTree中的节点数据，并按照所储存的数据对节点进行复原。<br>我们打开GraphView脚本，添加以下代码：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 临时字典，用于初始化节点图的，用完记得把内存释放掉
        /// &lt;/summary&gt;
        private Dictionary&lt;DialogNodeDataBase, NodeViewBase&gt; NodeDirt;

        /// &lt;summary&gt;
        /// 重置节点图
        /// &lt;/summary&gt;
        public void ResetNodeView()
        &#123;
            if (treeData != null)
            &#123;
                //初始化字典
                NodeDirt = new Dictionary&lt;DialogNodeDataBase, NodeViewBase&gt;();
                var nodeData = treeData.ChildNodeDataList;

                //检查StartNode是否存在
                if (treeData.StartNodeData == null)
                &#123;
                    CreateNode(NodeType.Start);
                &#125;
                else
                &#123;
                    RecoveryNode(treeData.StartNodeData);
                &#125;

                //恢复节点
                foreach (var node in nodeData)
                &#123;
                    RecoveryNode(node);
                &#125;

                //清除字典，后面会讲到为什么
                NodeDirt.Clear();
            &#125;
        &#125;
</code></pre>
<p>上面的代码中，我们提供了一个复原节点图的函数，我们在这里遍历DialongTree记录的所有节点，并依次还原所有的节点跟连线。</p>
<p>首先还原节点，在GraphView增加以下代码：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 恢复节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;DialogNodeData&quot;&gt;&lt;/param&gt;
        private void RecoveryNode(DialogNodeDataBase DialogNodeData)
        &#123;
            if (DialogNodeData == null)
            &#123;
                return;
            &#125;

            NodeViewBase nodeView = null;
            //恢复节点的核心部分，新增的节点需要在这里进行恢复方式的添加
            switch (DialogNodeData.NodeType)
            &#123;
                case NodeType.Start:
                &#123;
                    nodeView = new StartNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    nodeView = new EndNodeView(DialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(DialogNodeData.Position, nodeView.GetPosition().size));
            this.AddElement(nodeView);
        &#125;
</code></pre>
<p>在RecoveryNode方法中，我们根据所传的DialogDataBase对象，创建出对应的NodeViewBase。这里跟创建节点的CreateNode方法不同，我们不需要再创建出节点的Data层，我们只需要根据已有的Data，复原出节点的View层就可以了。</p>
<p>在复原节点的时候，我们需要让节点回到他们原本的位置，所以现在我们需要记录节点的位置信息。还记得我们之前用来处理节点图变化的OnGraphViewChanged函数吗？我们直接在那里监听节点的位置变化就行了。修改OnGraphViewChanged函数，在末尾加入以下代码：</p>
<pre><code class="C#">            //遍历节点，记录节点位置信息
            nodes.ForEach(node =&gt;
            &#123;
                NodeViewBase nodeView = node as NodeViewBase;
                if (nodeView != null &amp;&amp; nodeView.DialogNodeData != null)
                &#123;
                    nodeView.DialogNodeData.Position = nodeView.GetPosition().position;
                &#125;
            &#125;);
</code></pre>
<p>既然记录了节点位置，我们不妨也记录一下节点视图的位置与缩放，在打开编辑器的时候也进行复原，这样我们就能保证用户下一次打开编辑器时节点图与上次关闭保持一致。刚好Unity在GraphView中提供了一个viewTransformChanged事件，跟GraphViewChanged一样，我们在GraphView脚本里添加OnViewTransformChanged函数，代码如下：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// graphView的Transform发生变化时触发
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;graphView&quot;&gt;&lt;/param&gt;
        private void OnViewTransformChanged(GraphView graphView)
        &#123;
            if (treeData != null)
            &#123;
                //保存视图Transform信息
                treeData.GraphViewData.Position = contentViewContainer.transform.position;
                treeData.GraphViewData.Scale = contentViewContainer.transform.scale;
            &#125;
        &#125;
</code></pre>
<p>在DialogGraphView()中监听事件：</p>
<pre><code class="C#">            //监听视图Transform变化事件
            viewTransformChanged += OnViewTransformChanged;
</code></pre>
<p>现在，节点的复原已经完成了，且GraphView的位置跟缩放也将与保存时的状态保存一致。</p>
<p>但距离我们解析复原节点图完成还剩下最后一个关键部分，复原节点端口间的连线。根据这套对话系统的设计，我们对话节点的输入端口可以与多个端口连接，而输出端口只能与一个端口连接。在每一个节点的DialogNodeDataBase中，都有一个ChildNode列表用来记录该节点所连的子节点。因此我们可以先遍历图里的所有节点，再分别遍历节点里面的ChildNode，将每一个子节点的输入端口与父节点对应的输出端口相连就可以了。我们打开GraphView脚本，增加以下代码：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 链接两个点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;_outputPort&quot;&gt;outputPort&lt;/param&gt;
        /// &lt;param name=&quot;_inputPort&quot;&gt;inputPort&lt;/param&gt;
        private void AddEdgeByPorts(Port _outputPort, Port _inputPort)
        &#123;
            //虽然是不可能发生，但还是保守一点
            if (_outputPort.node == _inputPort.node)
            &#123;
                return;
            &#125;

            Edge tempEdge = new Edge()
            &#123;
                input = _inputPort,
                output = _outputPort
            &#125;;
            tempEdge.input.Connect(tempEdge);
            tempEdge.output.Connect(tempEdge);
            Add(tempEdge);
        &#125;

        /// &lt;summary&gt;
        /// 恢复节点连线
        /// &lt;/summary&gt;
        private void RecoveryEdge(DialogNodeDataBase DialogNodeData)
        &#123;
            if (DialogNodeData.ChildNode == null)
            &#123;
                return;
            &#125;

            for (int i = 0; i &lt; DialogNodeData.ChildNode.Count; i++)
            &#123;
                //没连就跳过
                if (DialogNodeData.ChildNode[i] == null)
                &#123;
                    continue;
                &#125;

                Port _output = NodeDirt[DialogNodeData].outputContainer[i].Q&lt;Port&gt;();
                Port _input = NodeDirt[DialogNodeData.ChildNode[i]].inputContainer[0].Q&lt;Port&gt;();

                AddEdgeByPorts(_output, _input);
            &#125;
        &#125;
</code></pre>
<p>上面代码我们添加了连接两个Port的函数，用的是Unity提供的API，很简单。接下来我们添加了一个能根据DialogNodeDataBase对象，遍历其子节点并复原连线的函数。由于我们的连接操作是在View层的事情，我们需要持有根据DialogNodeDataBase对象所创建的NodeViewBase对象。为了避免耦合，且我们的复原操作仅在DialogTree打开时进行一次，所以这里我们使用了一个临时的字典来缓存对象间互相持有的关系。字典的填充在复原节点的时候进行，我们修改RecoveryNode函数，在函数末尾加入以下代码：</p>
<pre><code class="C#">        NodeDirt.Add(DialogNodeData, nodeView);
</code></pre>
<p>现在，节点图的连线部分也完成了，我们来做最后的收尾工作。我们将在GraphView脚本中创建一个静态变量，用于实现简单的单例模式。代码如下：</p>
<pre><code class="C#">        public static DialogGraphView Instance;

        public DialogGraphView()
        &#123;
            //以上代码省略，在DialogGraphView末尾添加下面代码即可

            //简单的单例模式
            Instance = this;
        &#125;
</code></pre>
<p>修改ResetNodeView方法，增加复原节点连线的逻辑，代码如下：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 重置节点图
        /// &lt;/summary&gt;
        public void ResetNodeView()
        &#123;
            if (treeData != null)
            &#123;
                //初始化字典
                NodeDirt = new Dictionary&lt;DialogNodeDataBase, NodeViewBase&gt;();
                var nodeData = treeData.ChildNodeDataList;

                //检查StartNode是否存在
                if (treeData.StartNodeData == null)
                &#123;
                    CreateNode(NodeType.Start);
                &#125;
                else
                &#123;
                    RecoveryNode(treeData.StartNodeData);
                &#125;

                //恢复节点
                foreach (var node in nodeData)
                &#123;
                    RecoveryNode(node);
                &#125;

                //恢复节点边
                RecoveryEdge(treeData.StartNodeData);
                foreach (var node in nodeData)
                &#123;
                    RecoveryEdge(node);
                &#125;

                //清除字典
                NodeDirt.Clear();
            &#125;
        &#125;
</code></pre>
<p>现在我们打开DialogGraphWindow脚本，在末尾调用ResetNodeView()方法。代码如下：</p>
<pre><code class="C#">        public void CreateGUI()
        &#123;
            var visualTree =
                AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogGraphWindow.uxml&quot;);
            visualTree.CloneTree(rootVisualElement);

            _graphView = rootVisualElement.Q&lt;DialogGraphView&gt;(&quot;DialogGraphView&quot;);

            _inspectorView = rootVisualElement.Q&lt;InspectorView&gt;(&quot;InspectorView&quot;);

            var saveButton = rootVisualElement.Q&lt;ToolbarButton&gt;(&quot;SaveButton&quot;);
            saveButton.clicked += OnSaveButtonClicked;

            //初始化节点图
            DialogGraphView.Instance.ResetNodeView();
        &#125;
</code></pre>
<p>现在我们打开DialogTree，可以看到，节点图完美复原。到此，我们完成了一个基本的对话系统节点编辑器。但现在我们只有Start跟End两个节点，这显然还不能算是一个对话系统。所以接下来，我们要做的就是拓展更多节点，完善我们的对话系统 。</p>
<h2 id="拓展更多节点"><a href="#拓展更多节点" class="headerlink" title="拓展更多节点"></a>拓展更多节点</h2><p>在前面的代码实现中，我们已经实现了一个节点View层与Data层的基类，NodeViewBase与DialogNodeDataBase。那么对于拓展节点，无非就是继承这两个类，并实现不同节点特有的功能而已。</p>
<p>所以现在我们来规划一下要实现的节点，本次我们先拓展两个基础的对话系统节点：</p>
<ul>
<li>顺序对话节点：能够按照从上到下的顺序输出节点内的对话语句</li>
<li>随机对话节点：能从节点内对话数据中随机选出一句进行输出。</li>
</ul>
<p>我们打开NodeType枚举，增加新的节点类型，代码如下：</p>
<pre><code class="C#">    public enum NodeType
    &#123;
        Start,
        RandomDialogNode,
        SequentialDialogNode,
        End,
    &#125;
</code></pre>
<p>首先我们来拓展顺序对话节点：<br>Data层：<br>新建一个SequentialDialogNodeData脚本，代码如下：</p>
<pre><code class="C#">namespace DialogueSystem
&#123;
    public class SequentialDialogNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.SequentialDialogNode;
    &#125;
&#125;
</code></pre>
<p>View层：<br>新建一个SequentialDialogNodeView脚本，代码如下：</p>
<pre><code class="C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace DialogueSystem
&#123;
    public class SequentialDialogNodeView : NodeViewBase
    &#123;
        private int nextIndex = 0;
        public SequentialDialogNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;SequentialDialogNode&quot;;
            
            Port input = GetPortForNode(this, Direction.Input, Port.Capacity.Multi);
            Port output = GetPortForNode(this, Direction.Output, Port.Capacity.Single);
            input.portName = &quot;Input&quot;;
            input.portColor = Color.yellow;
            output.portName = &quot;Output&quot;;
            output.portColor = Color.yellow;
            output.name = &quot;0&quot;;
            
            inputContainer.Add(input);
            outputContainer.Add(output);
            
            //工具条
            Toolbar toolbar = new Toolbar();
            ToolbarButton addButton = new ToolbarButton(AddTextField)
            &#123;
                text = &quot;Add&quot;
            &#125;;
            ToolbarButton delButton = new ToolbarButton(DeleteTextField)
            &#123;
                text = &quot;Del&quot;
            &#125;;
            toolbar.Add(addButton);
            toolbar.Add(delButton);
            
            toolbar.style.flexDirection = FlexDirection.RowReverse;
            contentContainer.Add(toolbar);
            
            while (nextIndex &lt; DialogNodeData.OutputItems.Count)
            &#123;
                AddTextField();
            &#125;
            
            if (DialogNodeData.ChildNode.Count &lt; 1)
            &#123;
                DialogNodeData.ChildNode.Add(null);
            &#125;
        &#125;
        
        public void AddTextField()
        &#123;
            if (DialogNodeData.OutputItems.Count &lt; nextIndex + 1)
            &#123;
                DialogNodeData.OutputItems.Add(default);
            &#125;

            //拿了个没有功能的按键当背景，这个按键并没有什么实质性的功能哈哈
            Button background = new Button();

            TextField textField = new TextField();
            textField.name = nextIndex.ToString();
            textField.style.minWidth = 160;
            //初始化
            textField.SetValueWithoutNotify(DialogNodeData.OutputItems[nextIndex]);

            textField.RegisterValueChangedCallback(evt =&gt;
            &#123;
                if (int.TryParse(textField.name, out int index))
                &#123;
                    DialogNodeData.OutputItems[index] = evt.newValue;
                &#125;
                else
                &#123;
                    Debug.LogError(&quot;textField.name(string) to int fail&quot;);
                &#125;
            &#125;);

            background.Add(textField);
            extensionContainer.Add(background);
            RefreshExpandedState();

            nextIndex++;
        &#125;
        
        public void DeleteTextField()
        &#123;
            if (nextIndex &gt; 0)
            &#123;
                nextIndex--;
                
                DialogNodeData.OutputItems.RemoveAt(DialogNodeData.OutputItems.Count - 1);
                extensionContainer.Remove(extensionContainer[nextIndex]);
            &#125;
        &#125;
    &#125;
&#125;
#endif
</code></pre>
<p>接下来是随机对话节点：<br>Data层：<br>新建一个RandomDialogNodeData脚本，代码如下：</p>
<pre><code class="C#">namespace DialogueSystem
&#123;
    public class RandomDialogNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.RandomDialogNode;
    &#125;
&#125;
</code></pre>
<p>View层：<br>新建一个RandomDialogNodeView脚本，代码如下：</p>
<pre><code class="C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace DialogueSystem
&#123;
    public class RandomDialogNodeView : NodeViewBase
    &#123;
        private int nextIndex = 0;

        public RandomDialogNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;RandomDialogNode&quot;;

            Port input = GetPortForNode(this, Direction.Input, Port.Capacity.Multi);
            Port output = GetPortForNode(this, Direction.Output, Port.Capacity.Single);
            input.portName = &quot;Input&quot;;
            input.portColor = Color.magenta;
            output.portName = &quot;Output&quot;;
            output.portColor = Color.magenta;
            output.name = &quot;0&quot;;

            inputContainer.Add(input);
            outputContainer.Add(output);
            
            //工具条
            Toolbar toolbar = new Toolbar();
            ToolbarButton addButton = new ToolbarButton(AddTextField)
            &#123;
                text = &quot;Add&quot;
            &#125;;
            ToolbarButton delButton = new ToolbarButton(DeleteTextField)
            &#123;
                text = &quot;Del&quot;
            &#125;;
            toolbar.Add(addButton);
            toolbar.Add(delButton);
            
            toolbar.style.flexDirection = FlexDirection.RowReverse;
            contentContainer.Add(toolbar);

            while (nextIndex &lt; DialogNodeData.OutputItems.Count)
            &#123;
                AddTextField();
            &#125;
            
            //加个判断，不然每开一次创一个
            if (DialogNodeData.ChildNode.Count &lt; 1)
            &#123;
                DialogNodeData.ChildNode.Add(null);
            &#125;
        &#125;
        
        public void AddTextField()
        &#123;
            if (DialogNodeData.OutputItems.Count &lt; nextIndex + 1)
            &#123;
                DialogNodeData.OutputItems.Add(default);
            &#125;

            //拿了个没有功能的按键当背景，这个按键并没有什么实质性的功能哈哈
            Button background = new Button();

            TextField textField = new TextField();
            textField.name = nextIndex.ToString();
            textField.style.minWidth = 160;
            //初始化
            textField.SetValueWithoutNotify(DialogNodeData.OutputItems[nextIndex]);

            textField.RegisterValueChangedCallback(evt =&gt;
            &#123;
                if (int.TryParse(textField.name, out int index))
                &#123;
                    DialogNodeData.OutputItems[index] = evt.newValue;
                &#125;
                else
                &#123;
                    Debug.LogError(&quot;textField.name(string) to int fail&quot;);
                &#125;
            &#125;);

            background.Add(textField);
            extensionContainer.Add(background);
            RefreshExpandedState();

            nextIndex++;
        &#125;
        
        public void DeleteTextField()
        &#123;
            if (nextIndex &gt; 0)
            &#123;
                nextIndex--;
                
                DialogNodeData.OutputItems.RemoveAt(DialogNodeData.OutputItems.Count - 1);
                extensionContainer.Remove(extensionContainer[nextIndex]);
            &#125;
        &#125;
    &#125;
&#125;
#endif
</code></pre>
<p>完成之后，我们打开GraphView脚本，编辑CreateNode、RecoveryNode方法，使节点能够在GraphView中创建，代码如下：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 新建节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
        private void CreateNode(NodeType type, Vector2 position = default)
        &#123;
            if (treeData == null)
            &#123;
                return;
            &#125;

            MakeSureTheFolder();
            NodeViewBase nodeView = null;

            //创建节点的核心，新增的节点需要在这里进行创建方式的添加
            switch (type)
            &#123;
                case NodeType.Start:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;StartNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new StartNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.RandomDialogNode:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;RandomDialogNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/RandomDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/RandomDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new RandomDialogNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.SequentialDialogNode:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;SequentialDialogNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/SequentialDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/SequentialDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new SequentialDialogNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;EndNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new EndNodeView(dialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            //添加节点被选择事件
            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(position, nodeView.GetPosition().size));

            //对Start节点做个特判
            if (nodeView.DialogNodeData.NodeType == NodeType.Start)
            &#123;
                treeData.StartNodeData = nodeView.DialogNodeData;
            &#125;
            else
            &#123;
                treeData.ChildNodeDataList.Add(nodeView.DialogNodeData);
            &#125;

            this.AddElement(nodeView);
        &#125;

        /// &lt;summary&gt;
        /// 恢复节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;DialogNodeData&quot;&gt;&lt;/param&gt;
        private void RecoveryNode(DialogNodeDataBase DialogNodeData)
        &#123;
            if (DialogNodeData == null)
            &#123;
                return;
            &#125;

            NodeViewBase nodeView = null;
            //恢复节点的核心部分，新增的节点需要在这里进行恢复方式的添加
            switch (DialogNodeData.NodeType)
            &#123;
                case NodeType.Start:
                &#123;
                    nodeView = new StartNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.RandomDialogNode:
                &#123;
                    nodeView = new RandomDialogNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.SequentialDialogNode:
                &#123;
                    nodeView = new SequentialDialogNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    nodeView = new EndNodeView(DialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(DialogNodeData.Position, nodeView.GetPosition().size));
            NodeDirt.Add(DialogNodeData, nodeView);

            this.AddElement(nodeView);
        &#125;
</code></pre>
<p>最后，修改右键菜单，代码如下：</p>
<pre><code class="C#">        /// &lt;summary&gt;
        /// 右键菜单
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;
        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        &#123;
            base.BuildContextualMenu(evt);
            Debug.Log(evt.mousePosition);

            //将鼠标世界坐标转为视图本地坐标
            clickPosition = contentViewContainer.WorldToLocal(evt.mousePosition);

            if (treeData.StartNodeData == null)
            &#123;
                evt.menu.AppendAction(&quot;Create StartNode&quot;, x =&gt; &#123; CreateNode(NodeType.Start, clickPosition); &#125;);
            &#125;

            evt.menu.AppendAction(&quot;Create RandomDialogNode&quot;,
                x =&gt; &#123; CreateNode(NodeType.RandomDialogNode, clickPosition); &#125;);
            evt.menu.AppendAction(&quot;Create SequentialDialogNode&quot;,
                x =&gt; CreateNode(NodeType.SequentialDialogNode, clickPosition));
            evt.menu.AppendAction(&quot;Create EndNode&quot;, x =&gt; &#123; CreateNode(NodeType.End, clickPosition); &#125;);
        &#125;
</code></pre>
<p>现在我们回到Unity，随便打开一个节点编辑器，创建我们的新节点试试。可以看到，节点正常被创建了出来，并且我们在节点里面编辑数据，节点对应的DialogNodeDataBase对象中的数据也会同步编辑。</p>
<p><img src="https://img-blog.csdnimg.cn/b4271061553641b798e980e692290e19.png#pic_center" alt="对话节点图"></p>
<p>到这里，我们的对话系统的对话数据跟节点编辑器部分就已经完成了。我们完成了两个基本的系统流程节点，还有两个用于对话控制的对话节点。根据我们的系统架构，我们还可以自由拓展出更多的自定义节点，比如选择对话节点，事件节点等等。在编辑器中我们实现了利用节点图来编辑对话数据文件的功能，而在数据文件中我们只让它负责了数据处理的相关逻辑。具体的对话逻辑我们并不是在数据类中实现，这样的设计不仅实现了解耦，还实现了模块化，便于维护、拓展新的节点模块。下一节，我们将实现对话系统的的逻辑处理部分，以及能挂在Unity GameObject上的Mono对话系统组件。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://bigotry0.github.io">Bigotry0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://bigotry0.github.io/2023/02/25/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/">https://bigotry0.github.io/2023/02/25/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://bigotry0.github.io" target="_blank">游戏开发小地方</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/posts_cover/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/03/04/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" title="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件"><img class="cover" src="/img/posts_cover/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于GraphView的对话系统设计（二）节点逻辑处理与对话组件</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/Avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bigotry0</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Bigotry0" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lim.young@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">对话系统特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">系统实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">编辑器部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E8%8A%82%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">对话节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%9B%BE%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">节点图的保存与解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%9B%B4%E5%A4%9A%E8%8A%82%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">拓展更多节点</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/04/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" title="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件"><img src="/img/posts_cover/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件"/></a><div class="content"><a class="title" href="/2023/03/04/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" title="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件">基于GraphView的对话系统设计（二）节点逻辑处理与对话组件</a><time datetime="2023-03-03T17:41:39.000Z" title="发表于 2023-03-04 01:41:39">2023-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/25/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/" title="基于GraphView的对话系统设计（一）对话数据与节点编辑器"><img src="/img/posts_cover/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于GraphView的对话系统设计（一）对话数据与节点编辑器"/></a><div class="content"><a class="title" href="/2023/02/25/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/" title="基于GraphView的对话系统设计（一）对话数据与节点编辑器">基于GraphView的对话系统设计（一）对话数据与节点编辑器</a><time datetime="2023-02-25T06:35:34.000Z" title="发表于 2023-02-25 14:35:34">2023-02-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Bigotry0</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">到底了，真的没有了</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    btf.addModeChange('mermaid', () => {
      window.runMermaid()
    })

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>