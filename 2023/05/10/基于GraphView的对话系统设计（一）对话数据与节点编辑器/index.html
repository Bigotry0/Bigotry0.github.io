<!-- build time:Thu May 11 2023 00:25:08 GMT+0800 (香港标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="游戏开发小地方" href="https://bigotry0.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="游戏开发小地方" href="https://bigotry0.github.io/atom.xml"><link rel="alternate" type="application/json" title="游戏开发小地方" href="https://bigotry0.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://bigotry0.github.io/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/"><title>基于GraphView的对话系统设计（一）对话数据与节点编辑器 | Bigotry0 = 游戏开发小地方</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">基于GraphView的对话系统设计（一）对话数据与节点编辑器</h1><div class="meta"><span class="item" title="创建时间：2023-05-10 22:46:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-10T22:46:13+08:00">2023-05-10</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Bigotry0</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitspjpbj20zk0m81ky.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://bigotry0.github.io/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Bigotry0"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="游戏开发小地方"></span><div class="body md" itemprop="articleBody"><blockquote><h2 id="对话系统特点"><a class="anchor" href="#对话系统特点">#</a> 对话系统特点</h2><ul><li>使用节点编辑器编辑对话，便于策划等非程序岗参与项目开发</li><li>拓展性强，可自定义节点，方便根据项目需求进行拓展</li><li>使用逻辑简单、直观，无需进行大量配置</li><li>对话数据持久化储存，且带增删管理</li><li>节点可进行逻辑控制</li></ul></blockquote><h2 id="系统实现"><a class="anchor" href="#系统实现">#</a> 系统实现</h2><p>首先，我们设计一下对话系统进行的结构分层，在该对话系统中，我们将其分为节点编辑器、对话数据，对话逻辑处理系统三个部分。我们可以用下图来表示：</p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR</pre></td></tr><tr><td data-num="2"></td><td><pre>A<span class="token text string">[Editor]</span> <span class="token arrow operator">--></span> B<span class="token text string">[Data]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>B <span class="token arrow operator">--></span> A</pre></td></tr><tr><td data-num="4"></td><td><pre>B <span class="token arrow operator">--></span> D<span class="token text string">[System]</span></pre></td></tr></table></figure><p>对话数据采用 Scriptableobject 来实现编辑模式下的数据可变性和运行模式下的数据可持久性，节点编辑器于编辑器下运行，为对话数据文件唯一编辑方式。</p><h2 id="编辑器部分"><a class="anchor" href="#编辑器部分">#</a> 编辑器部分</h2><p>对于该节点式编辑器的制作，我们这里使用的是 Unity 自带的 GraphView API 来进行开发，GraphView 的相关中文资料较少，在开发的过程中也是踩到了不少坑。<br>为了创建一个编辑器窗口，我们打开资源菜单，选择创建，选择 UI 工具箱（UI UIToolkit），选择编辑器窗口，会出现以下画面：</p><p><img data-src="https://img-blog.csdnimg.cn/043b2dcd416847628392fdbed2e96180.png" alt="UI UIToolkit创建菜单"></p><p>我们可以将其命名为 DialogGraphWindow，点击创建，Unity 会自动为我们创建文件。</p><p><img data-src="https://img-blog.csdnimg.cn/283cd0eb141c4784a36c04cfefc25dff.png" alt="命名"></p><p>创建完成后，首先是编辑器的主体部分，双击创建好的 DialogGraphWindow.uxml 文件，Unity 会自动打开 UIToolkit 中的 UIBuilder，在该窗口中，我们可以自定义我们的窗口布局，下面是本对话系统的 UI 布局：</p><p><img data-src="https://img-blog.csdnimg.cn/857f7810e67a48bd89b89671af5c2bd7.png#pic_center" alt="简易的布局"><br>布局结构很简单，值得注意的是，我们需要在面板的 Hierarchy 窗口中点击.uxml 文件，然后在 Inspector 窗口中勾选 Editor Extension Authoring 选项，这样我们才可以在编辑模式下使用编辑器 UI 组件，如下图：</p><p><img data-src="https://img-blog.csdnimg.cn/750d7c8281bd44909f111a9e8379a782.png#pic_center" alt="勾选Editor Extension Authoring"></p><p>其中的 DialogGraphView 组件，并不是在 Stander 窗口里创建。我们没有在 Standard 中看到这一 UI 组件，这是因为 GraphView 组件是需要我们自己手动创建的，新建一个脚本，让他继承 GraphView，并进行该自定义 UI 组件的配置，代码如下：</p><pre><code class="language-C#">#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace DialogueSystem
&#123;
    public class DialogGraphView : GraphView
    &#123;
        public new class UxmlFactory : UxmlFactory&lt;DialogGraphView, GraphView.UxmlTraits&gt;
        &#123;
        &#125;

        public DialogGraphView()
        &#123;
            //增加格子背景
            Insert(0, new GridBackground());

            //增加内容缩放，拖动，拖拽，框选控制器
            this.AddManipulator(new ContentZoomer());
            this.AddManipulator(new ContentDragger());
            this.AddManipulator(new SelectionDragger());
            //框选 bug
            //大坑！控制器之间存在优先级
            //这就是为什么框选控制器放在选择拖放节点控制器之前会导致节点无法移动
            //因为框选的优先级更高
            this.AddManipulator(new RectangleSelector());

            var styleSheet =
                AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;(
                    //此处填你项目对应 uss 文件路径
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogueTreeView.uss&quot;);
            styleSheets.Add(styleSheet);

            //初始化 treedata 布局
            if (treeData != null)
            &#123;
                contentViewContainer.transform.position = treeData.GraphViewData.Position;
                contentViewContainer.transform.scale = treeData.GraphViewData.Scale;
            &#125;
        &#125;
&#125;
#endif
</code></pre><p>打开 DialogGraphWindow.cs 脚本，修改脚本如下：</p><pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.UIElements;

namespace LFramework.AI.Kit.DialogueSystem
&#123;
    public class DialogGraphWindow : EditorWindow
    &#123;
        [MenuItem(&quot;Window/UI Toolkit/DialogueView&quot;)]
        public static void ShowExample()
        &#123;
            DialogueView wnd = GetWindow&lt;DialogueView&gt;();
            wnd.titleContent = new GUIContent(&quot;DialogueView&quot;);
        &#125;

        private DialogGraphView _graphView = null;

        public static void CloseEditorWindow()
        &#123;
            DialogGraphWindow wnd = GetWindow&lt;DialogGraphWindow&gt;();
            wnd.Close();
        &#125;

        public void CreateGUI()
        &#123;
            var visualTree =
                AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogGraphWindow.uxml&quot;);
            visualTree.CloneTree(rootVisualElement);

            _graphView = rootVisualElement.Q&lt;DialogGraphView&gt;(&quot;DialogGraphView&quot;);

            var saveButton = rootVisualElement.Q&lt;ToolbarButton&gt;(&quot;SaveButton&quot;);
            saveButton.clicked += OnSaveButtonClicked;
        &#125;

        //保存资源文件
        private void OnSaveButtonClicked()
        &#123;
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        &#125;

        private void OnDestroy()
        &#123;
            AssetDatabase.SaveAssets();
        &#125;
    &#125;
&#125;
#endif
</code></pre><p>现在我们回到 Untiy，重新编译后，点击 project 按钮，就可以看到我们刚刚创建好的组件。拖拽组件到窗口中，或许屏幕上并没有变化。选中 GraphView 组件，修改其 grow 值为 1，现在我们应该就能看到我们的 GraphView 了。完成之后，我们来开始创建我们的对话节点。</p><h2 id="对话节点"><a class="anchor" href="#对话节点">#</a> 对话节点</h2><p>对于每一个对话节点，我们都可以将其分为 Data 层和 View 层。在 View 层中，我们只是对我们的节点数据进行可视化处理，在 View 层中，我们也能对对话节点进行编辑，编辑的目标就是我们的 Data 层。Data 层才是我们对话数据的关键部分，保存节点包含的各种信息。<br>在该对话系统中，我们采用了 Scriptableobject 来进行数据的存储，使用 Scriptableobject 可以实现在编辑器中的数据持久化，而且还能达成数据的可复用性。<br>所以首先，我们需要一个用来管理所有对话节点数据的数据结构类，创建一个 DialogTree 类，代码如下：</p><pre><code class="language-C#">using System;
using System.Collections.Generic;
using LFramework.AI.Kit.DialogueSystem;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace DialogueSystem
&#123;
    [CreateAssetMenu(menuName = &quot;Create new DialogTreeData&quot;,fileName = &quot;DialogTreeData&quot;)]
    public class DialogTree : ScriptableObject
    &#123;
        public DialogNodeDataBase StartNodeData = null;

        public List&lt;DialogNodeDataBase&gt; ChildNodeDataList = new List&lt;DialogNodeDataBase&gt;();

		// 用来储存节点视图信息
        [Serializable]
        public class ViewData
        &#123;
            public Vector3 Position;
            public Vector3 Scale = new Vector3(1, 1, 1);
        &#125;

        public ViewData GraphViewData = new ViewData();
    &#125;
&#125;
</code></pre><p>在这里，我们定义一个头结点对象和一个子节点列表，每个对话树 Scriptableobject 都记录着他所管理的所有对话节点的信息，所以接下来，我们来定义节点数据的基类 DialogDataBase，代码如下:</p><pre><code class="language-C#">using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

namespace DialogueSystem
&#123;
    public abstract class DialogNodeDataBase : ScriptableObject
    &#123;
        /// &lt;summary&gt;
        /// 节点坐标
        /// &lt;/summary&gt;
        [HideInInspector] public Vector2 Position = Vector2.zero;

        [HideInInspector] public string Path;

        /// &lt;summary&gt;
        /// 节点类型
        /// &lt;/summary&gt;
        public abstract NodeType NodeType &#123; get; &#125;

        protected DialogNodeDataBase()
        &#123;
        &#125;

        private void OnValidate()
        &#123;
#if UNITY_EDITOR
            AssetDatabase.SaveAssets();
#endif
        &#125;

        public List&lt;string&gt; OutputItems = new List&lt;string&gt;();

        public List&lt;DialogNodeDataBase&gt; ChildNode = new List&lt;DialogNodeDataBase&gt;();
    &#125;
&#125;
</code></pre><p>在这个对话节点基类中，我们定义了所有节点的通用属性，其中最重要的是两个列表，一个是用于储存节点输出信息的 OutputItems 列表，他可以用于储存对话数据，也可以根据不同的需求，储存节点所需的字符串信息。另一个 ChildNode 列表用于储存对话节点间的关系，包含了该节点的所有子节点对象，这是这套对话系统的关键。</p><p>在读取数据时，根据对话树的头节点，按照节点连线规则一直往下选择下一个对话节点，重复读取直至对话节点进行至 End 节点结束。这样的逻辑有点像是链表。</p><p>除此之外，节点中的 NodeType 属性也是对话系统的关键部分，在读取一个节点时，通过检测节点的类型，我们可以使用不同的方式来处理节点，以实现节点的逻辑控制，这部分我们将在后面构建对话系统的数据处理部分详细介绍。</p><p>所以，接下来我们来创建两个关键的对话节点，StartNode 跟 EndNode。在创建节点之前，我们先创建一个新的 C# 脚本，在脚本中创建一个 NodeType 枚举类，代码如下：</p><pre><code class="language-C#">namespace DialogueSystem
&#123;
    public enum NodeType
    &#123;
        Start,
        End,
    &#125;
&#125;
</code></pre><p>接下来是我们的两个对话节点，代码如下；<br>StartNode：</p><pre><code class="language-C#">namespace DialogueSystem
&#123;
    public class StartNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.Start;
    &#125;
&#125;
</code></pre><p>EndNode：</p><pre><code class="language-C#">namespace DialogueSystem
&#123;
    public class EndNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.End;
    &#125;
&#125;
</code></pre><p>这两个都继承了我们的 DialogDataBase 基类，在这里我们只需要指定他们的类型即可。</p><p>创建好节点的 Data 层后，我们来实现对话节点的 View 层，创建一个 NodeViewBase 基类，代码如下：</p><pre><code class="language-C#">#if UNITY_EDITOR
using System;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DialogueSystem
&#123;
    public abstract class NodeViewBase : Node
    &#123;
        public Action&lt;NodeViewBase&gt; OnNodeSelected;
        
        public string GUID;

        //对话数据
        public DialogNodeDataBase DialogNodeData = null;

        public NodeViewBase(DialogNodeDataBase dialogNodeData) : base()
        &#123;
            GUID = Guid.NewGuid().ToString();
            DialogNodeData = dialogNodeData;
            //大坑，新版本unity不自动在磁盘上应用资源更新，必须先给目标物体打上Dirty标记
            EditorUtility.SetDirty(DialogNodeData);
        &#125;

        public Port GetPortForNode(NodeViewBase node, Direction portDirection,
            Port.Capacity capacity = Port.Capacity.Single)
        &#123;
            return node.InstantiatePort(Orientation.Horizontal, portDirection, capacity, typeof(bool));
        &#125;

        public override void OnSelected()
        &#123;
            base.OnSelected();
            OnNodeSelected?.Invoke(this);
        &#125;
    &#125;
&#125;
#endif
</code></pre><p>view 层我们主要使用了 GraphView 的 Node 基类，我们的基类继承了 Node，这样可以使我们在 GraphView 中创建出自定义的节点 UI，上面的代码我们重写了 OnSelected 方法，将节点被选中的事件发送出去。</p><p>按照我们的设计，开始节点只有一个输出口，且接口只能连接一个子节点，也就是说，StartNode 拥有一个单一输出口。而 EndNode 则可以接受多个输入，但他不能有输出口，因为 EndNode 节点表示的是对话树的终止处，所以 EndNode 将有一个支持多输入的输入口，我们来实现这两个节点，代码如下：<br>StartNode：</p><pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DialogueSystem
&#123;
    public class StartNodeView : NodeViewBase
    &#123;
        public StartNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;Start&quot;;
            
            Port output = GetPortForNode(this, Direction.Output, Port.Capacity.Single);
            output.portName = &quot;output&quot;;
            output.name = &quot;0&quot;;
            
            output.portColor = Color.green;
            outputContainer.Add(output);
            
            if (DialogNodeData.ChildNode.Count &lt; 1)
            &#123;
                DialogNodeData.ChildNode.Add(null);
            &#125;
        &#125;
    &#125;
&#125;
#endif
</code></pre><p>EndNode：</p><pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DialogueSystem
&#123;
    public class EndNodeView : NodeViewBase
    &#123;
        public EndNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;End&quot;;
            
            Port input = GetPortForNode(this, Direction.Input, Port.Capacity.Multi);
            input.portName = &quot;input&quot;;
            input.portColor = Color.gray;
            
            inputContainer.Add(input);
        &#125;
    &#125;
&#125;
#endif
</code></pre><p>很简单，我们为我们的节点创建了上面所描述类型的 Port，并把他们分别添加进 InputContainner 和 OutputContainner 中。接下来，我们回到 GraphView 脚本，我们来拓展右键菜单，让我们可以创建出我们的节点。代码如下：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 菜单点击时鼠标位置
        /// &lt;/summary&gt;
        private Vector2 clickPosition;

        /// &lt;summary&gt;
        /// 节点点击事件
        /// &lt;/summary&gt;
        public Action&lt;NodeViewBase&gt; OnNodeSelected;

        public static DialogTree treeData = null;

        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        &#123;
            base.BuildContextualMenu(evt);
            Debug.Log(evt.mousePosition);

            //将鼠标世界坐标转为视图本地坐标
            clickPosition = contentViewContainer.WorldToLocal(evt.mousePosition);

            evt.menu.AppendAction(&quot;Create StartNode&quot;, x =&gt;
            &#123;
                var dialogNodeData = ScriptableObject.CreateInstance&lt;StartNodeData&gt;();
                var nodeView = new StartNodeView(dialogNodeData)
                &#123;
                    //设置点击事件
                    OnNodeSelected = OnNodeSelected
                &#125;;
                nodeView.SetPosition(new Rect(clickPosition, nodeView.GetPosition().size));
                this.AddElement(nodeView);
            &#125;);

            evt.menu.AppendAction(&quot;Create EndNode&quot;, x =&gt;
            &#123;
                var dialogNodeData = ScriptableObject.CreateInstance&lt;EndNodeData&gt;();
                var nodeView = new EndNodeView(dialogNodeData)
                &#123;
                    //设置点击事件
                    OnNodeSelected = OnNodeSelected
                &#125;;
                nodeView.SetPosition(new Rect(clickPosition, nodeView.GetPosition().size));
                this.AddElement(nodeView);
            &#125;);
        &#125;
</code></pre><p>如果我们现在回到 Unity 打开我们节点编辑器，右键创建节点，我们会看到两个节点都成功的创建了出来。可当我们尝试连接节点时，我们会发现所有的节点端口都变灰了，我们无法连接任何节点。这是因为我们还没有配置节点的连接规则，重新回到 GraphView 脚本，Override GetCompatiblePorts 函数。代码如下：</p><pre><code class="language-C#">        //节点链接规则
        public override List&lt;Port&gt; GetCompatiblePorts(Port startPort, NodeAdapter nodeAdapter)
        &#123;
            return ports.ToList().Where(endPort =&gt;
                endPort.direction != startPort.direction &amp;&amp;
                endPort.node != startPort.node &amp;&amp;
                endPort.portType == startPort.portType
            ).ToList();
        &#125;
</code></pre><p>连接规则很简单，即节点自己不能连接自己，节点接口方向不能相同，且只有相同类型的端口可以互相连接。在我们这个系统中，节点间的连线仅表示数据流向，不涉及数据类型，项目里所有节点接口的类型都被我统一为 bool 类型。</p><p>现在我们回到 Unity，打开节点编辑器，创建节点，连接，这次的效果就符合我们的预期了。</p><p><img data-src="https://img-blog.csdnimg.cn/b86f50bdc300473c80fb55ae09f92dc2.png#pic_center" alt="在这里插入图片描述"><br>现在我们完成的是节点 UI 的显示，也就是说，现阶段的节点是没有任何实际功能的。我们来继续完善 Start 跟 End 节点，使他们与他们对应的 Data 层对象相关联。</p><p>首先是创建节点的部分，我们打开 GraphView 脚本，增加一个 CreateNode 方法。代码如下：</p><pre><code class="language-C#">        //确保目录存在
        private void MakeSureTheFolder()
        &#123;
            //TODO：做成可自行设置的对话资源文件部署
            if (!AssetDatabase.IsValidFolder(&quot;Assets/DialogueData/NodeData&quot;))
            &#123;
                AssetDatabase.CreateFolder(&quot;Assets&quot;, &quot;DialogueData&quot;);
                AssetDatabase.CreateFolder(&quot;Assets/DialogueData&quot;, &quot;NodeData&quot;);
            &#125;
        &#125;

        /// &lt;summary&gt;
        /// 新建节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
        private void CreateNode(NodeType type, Vector2 position = default)
        &#123;
            if (treeData == null)
            &#123;
                return;
            &#125;

            MakeSureTheFolder();
            NodeViewBase nodeView = null;

            //创建节点的核心，新增的节点需要在这里进行创建方式的添加
            switch (type)
            &#123;
                case NodeType.Start:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;StartNodeData&gt;();
                    dialogNodeData.Path = $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new StartNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;EndNodeData&gt;();
                    dialogNodeData.Path = $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new EndNodeView(dialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            //添加节点被选择事件
            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(position, nodeView.GetPosition().size));

            this.AddElement(nodeView);
        &#125;
</code></pre><p>我们在创建节点 UI 之前，都会创建一个对应节点的 DialogNodeDataBase 对象，并将其保存为 asset 文件。而在 View 中，在创建出节点 UI 时，将持有刚创建的 DialogNodeDataBase 对象。<br>现在我们创建节点就可以直接使用 CreateNode 函数了，我们可以修改右键菜单，使用新的创建节点方法，修改 GraphView 中代码如下：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 右键菜单
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;
        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        &#123;
            base.BuildContextualMenu(evt);
            Debug.Log(evt.mousePosition);

            //将鼠标世界坐标转为视图本地坐标
            clickPosition = contentViewContainer.WorldToLocal(evt.mousePosition);

            if (treeData.StartNodeData == null)
            &#123;
                evt.menu.AppendAction(&quot;Create StartNode&quot;, x =&gt; &#123; CreateNode(NodeType.Start, clickPosition); &#125;);
            &#125;

            evt.menu.AppendAction(&quot;Create EndNode&quot;, x =&gt; &#123; CreateNode(NodeType.End, clickPosition); &#125;);
        &#125;
</code></pre><p>到这里，我们的单个节点才总算是相对完整了，但是，我们还没有处理节点与节点间的数据连接，在该对话系统的设计中，节点与节点间的连接表示的是对话节点数据的读取顺序，Unity 在 GraphView 中提供了一个 graphViewChanged 事件，该事件可以监听 GraphView 中的各种变化，包括节点的移动，连线的创建、删除等，我们打开 GraphView 脚本，增加以下代码：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 节点图变化事件
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;graphviewchange&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private GraphViewChange OnGraphViewChanged(GraphViewChange graphviewchange)
        &#123;
            if (graphviewchange.elementsToRemove != null)
            &#123;
                graphviewchange.elementsToRemove.ForEach(elem =&gt;
                &#123;
                    //连线删除
                    else if (elem is Edge edge)
                    &#123;
                        NodeViewBase parentNodeView = edge.output.node as NodeViewBase;
                        NodeViewBase childNodeView = edge.input.node as NodeViewBase;
                        if (parentNodeView != null &amp;&amp; childNodeView != null)
                        &#123;
                            if (int.TryParse(edge.output.name, out int index))
                            &#123;
                                parentNodeView.DialogNodeData.ChildNode[index] = null;
                            &#125;
                            else
                            &#123;
                                Debug.LogError(&quot;Node.name(string) to int fail&quot;);
                            &#125;
                        &#125;
                    &#125;
                &#125;);
            &#125;

            if (graphviewchange.edgesToCreate != null)
            &#123;
                //创建连线
                graphviewchange.edgesToCreate.ForEach(edge =&gt;
                &#123;
                    NodeViewBase parentNodeView = edge.output.node as NodeViewBase;
                    NodeViewBase childNodeView = edge.input.node as NodeViewBase;

                    if (parentNodeView != null &amp;&amp; childNodeView != null)
                    &#123;
                        if (int.TryParse(edge.output.name, out int index))
                        &#123;
                            parentNodeView.DialogNodeData.ChildNode[index] = childNodeView.DialogNodeData;
                        &#125;
                        else
                        &#123;
                            Debug.LogError(&quot;Node.name(string) to int fail&quot;);
                        &#125;
                    &#125;
                &#125;);
            &#125;

            return graphviewchange;
        &#125;
</code></pre><p>然后在初始化 GraphView 的时候往 graphViewChanged 事件添加我们的 OnGraphViewChanged 方法，在 GraphView 脚本中的 DialogGraphView () 方法添加以下代码即可。代码如下：</p><pre><code class="language-C#">            //监听graphView变化事件
            graphViewChanged += OnGraphViewChanged;
</code></pre><p>创建连线时，我们获取一下该连线的两端节点，并将输入口的节点对应的 DialogNodeDataBase 对象添加进输出口节点的 DialogNodeDataBase 的子对象列表中。当然，在连线删除的时候，我们也应该同步删除父节点子对象列表中的对应子节点。</p><p>现在，节点间已经能够在数据层面上进行连接了，但我们还有一件重要的事情没有做。如果将节点编辑器关闭后再打开，我们会发现节点编辑器回到了初始状态，我们的节点数据并没有在节点图中展示。所以接下来我们来实现一下节点图的保存与解析。</p><h2 id="节点图的保存与解析"><a class="anchor" href="#节点图的保存与解析">#</a> 节点图的保存与解析</h2><p>我们在节点编辑器里编辑的节点，最终保存为一个个节点数据文件，还记得我们当时创建的 DialogTree 类吗？DialogTree 就是专门用来管理节点数据的数据结构类，我们修改 CreateNode 代码，在创建节点的时候将节点对象添加进 DialogTree 中。打开 GraphView 脚本，在 CreateNode 函数末尾加入代码，代码如下：</p><pre><code class="language-C#">            //对Start节点做个特判
            if (nodeView.DialogNodeData.NodeType == NodeType.Start)
            &#123;
                treeData.StartNodeData = nodeView.DialogNodeData;
            &#125;
            else
            &#123;
                treeData.ChildNodeDataList.Add(nodeView.DialogNodeData);
            &#125;
</code></pre><p>在一个 DialogTree 中，我们只能有一个 StartNode，并且 StartNode 对象是作为一个特别对待的节点储存在 DialogTree 中的 StartNodeData 变量中。现在我们可以更改一下编辑器的打开逻辑，不再是通过菜单栏打开节点编辑器，而是改成打开 DialogTree 对象的 asset 文间来打开节点编辑器，这样也可以在打开时获取到打开的 DialogTree 对象，从而对该 DialogTree 与 GraphView 进行关联。打开 DialogGraphWindow 脚本，编辑代码如下：</p><pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.UIElements;

namespace LFramework.AI.Kit.DialogueSystem
&#123;
    public class DialogGraphWindow : EditorWindow
    &#123;
        // 移除原先的打开方式
        // [MenuItem(&quot;Window/UI Toolkit/DialogueView&quot;)]
        // public static void ShowExample()
        // &#123;
        //
        //     DialogueView wnd = GetWindow&lt;DialogueView&gt;();
        //     wnd.titleContent = new GUIContent(&quot;DialogueView&quot;);
        // &#125;

        private DialogGraphView _graphView = null;

        // 打开DialogTree资源时触发
        [OnOpenAsset(1)]
        public static bool OnOpenAsssets(int id, int line)
        &#123;
            if (EditorUtility.InstanceIDToObject(id) is DialogTree tree)
            &#123;
                //打开不同DialogTree文件
                if (DialogGraphView.treeData != tree)
                &#123;
                    Debug.Log(DialogGraphView.treeData);
                    DialogGraphView.treeData = tree;

                    //判断窗口是否打开
                    if (HasOpenInstances&lt;DialogGraphWindow&gt;())
                    &#123;
                        CloseEditorWindow();
                    &#125;

                    //大大大大大坑！新版本unity不自动在磁盘上应用资源更新，必须先给目标物体打上Dirty标记
                    EditorUtility.SetDirty(tree);
                &#125;

                DialogGraphWindow wnd = GetWindow&lt;DialogGraphWindow&gt;();
                wnd.titleContent = new GUIContent(&quot;DialogueView&quot;);
                
                return true;
            &#125;
            return false;
        &#125;

        public static void CloseEditorWindow()
        &#123;
            DialogGraphWindow wnd = GetWindow&lt;DialogGraphWindow&gt;();
            wnd.Close();
        &#125;

        public void CreateGUI()
        &#123;
            var visualTree =
                AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogGraphWindow.uxml&quot;);
            visualTree.CloneTree(rootVisualElement);

            _graphView = rootVisualElement.Q&lt;DialogGraphView&gt;(&quot;DialogGraphView&quot;);

            _inspectorView = rootVisualElement.Q&lt;InspectorView&gt;(&quot;InspectorView&quot;);

            var saveButton = rootVisualElement.Q&lt;ToolbarButton&gt;(&quot;SaveButton&quot;);
            saveButton.clicked += OnSaveButtonClicked;
        &#125;

        //保存资源文件
        private void OnSaveButtonClicked()
        &#123;
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            Debug.Log(&quot;Save&quot;);
        &#125;

        private void OnDestroy()
        &#123;
            //对象销毁之前记得保存一下，保险
            AssetDatabase.SaveAssets();
        &#125;
    &#125;
&#125;
#endif
</code></pre><p>打开 GraphView 脚本，添加一个静态变量用于储存当前 DialogTree。代码如下：</p><pre><code class="language-C#">        public static DialogTree treeData = null;
</code></pre><p>回到 Unity，双击 DialogTree.asset 文件，可以看到，节点编辑器被成功打开。但是，我们还是没有在编辑器里看到任何节点，那是因为我们还没有对 DialogTree 中的数据进行处理。既然在 DialogTree 里已经有了我们整个对话树的节点数据，那我们是不是就可以在编辑器打开的时候，读取 DialogTree 中的节点数据，并按照所储存的数据对节点进行复原。<br>我们打开 GraphView 脚本，添加以下代码：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 临时字典，用于初始化节点图的，用完记得把内存释放掉
        /// &lt;/summary&gt;
        private Dictionary&lt;DialogNodeDataBase, NodeViewBase&gt; NodeDirt;

        /// &lt;summary&gt;
        /// 重置节点图
        /// &lt;/summary&gt;
        public void ResetNodeView()
        &#123;
            if (treeData != null)
            &#123;
                //初始化字典
                NodeDirt = new Dictionary&lt;DialogNodeDataBase, NodeViewBase&gt;();
                var nodeData = treeData.ChildNodeDataList;

                //检查StartNode是否存在
                if (treeData.StartNodeData == null)
                &#123;
                    CreateNode(NodeType.Start);
                &#125;
                else
                &#123;
                    RecoveryNode(treeData.StartNodeData);
                &#125;

                //恢复节点
                foreach (var node in nodeData)
                &#123;
                    RecoveryNode(node);
                &#125;

                //清除字典，后面会讲到为什么
                NodeDirt.Clear();
            &#125;
        &#125;
</code></pre><p>上面的代码中，我们提供了一个复原节点图的函数，我们在这里遍历 DialongTree 记录的所有节点，并依次还原所有的节点跟连线。</p><p>首先还原节点，在 GraphView 增加以下代码：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 恢复节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;DialogNodeData&quot;&gt;&lt;/param&gt;
        private void RecoveryNode(DialogNodeDataBase DialogNodeData)
        &#123;
            if (DialogNodeData == null)
            &#123;
                return;
            &#125;

            NodeViewBase nodeView = null;
            //恢复节点的核心部分，新增的节点需要在这里进行恢复方式的添加
            switch (DialogNodeData.NodeType)
            &#123;
                case NodeType.Start:
                &#123;
                    nodeView = new StartNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    nodeView = new EndNodeView(DialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(DialogNodeData.Position, nodeView.GetPosition().size));
            this.AddElement(nodeView);
        &#125;
</code></pre><p>在 RecoveryNode 方法中，我们根据所传的 DialogDataBase 对象，创建出对应的 NodeViewBase。这里跟创建节点的 CreateNode 方法不同，我们不需要再创建出节点的 Data 层，我们只需要根据已有的 Data，复原出节点的 View 层就可以了。</p><p>在复原节点的时候，我们需要让节点回到他们原本的位置，所以现在我们需要记录节点的位置信息。还记得我们之前用来处理节点图变化的 OnGraphViewChanged 函数吗？我们直接在那里监听节点的位置变化就行了。修改 OnGraphViewChanged 函数，在末尾加入以下代码：</p><pre><code class="language-C#">            //遍历节点，记录节点位置信息
            nodes.ForEach(node =&gt;
            &#123;
                NodeViewBase nodeView = node as NodeViewBase;
                if (nodeView != null &amp;&amp; nodeView.DialogNodeData != null)
                &#123;
                    nodeView.DialogNodeData.Position = nodeView.GetPosition().position;
                &#125;
            &#125;);
</code></pre><p>既然记录了节点位置，我们不妨也记录一下节点视图的位置与缩放，在打开编辑器的时候也进行复原，这样我们就能保证用户下一次打开编辑器时节点图与上次关闭保持一致。刚好 Unity 在 GraphView 中提供了一个 viewTransformChanged 事件，跟 GraphViewChanged 一样，我们在 GraphView 脚本里添加 OnViewTransformChanged 函数，代码如下：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// graphView的Transform发生变化时触发
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;graphView&quot;&gt;&lt;/param&gt;
        private void OnViewTransformChanged(GraphView graphView)
        &#123;
            if (treeData != null)
            &#123;
                //保存视图Transform信息
                treeData.GraphViewData.Position = contentViewContainer.transform.position;
                treeData.GraphViewData.Scale = contentViewContainer.transform.scale;
            &#125;
        &#125;
</code></pre><p>在 DialogGraphView () 中监听事件：</p><pre><code class="language-C#">            //监听视图Transform变化事件
            viewTransformChanged += OnViewTransformChanged;
</code></pre><p>现在，节点的复原已经完成了，且 GraphView 的位置跟缩放也将与保存时的状态保存一致。</p><p>但距离我们解析复原节点图完成还剩下最后一个关键部分，复原节点端口间的连线。根据这套对话系统的设计，我们对话节点的输入端口可以与多个端口连接，而输出端口只能与一个端口连接。在每一个节点的 DialogNodeDataBase 中，都有一个 ChildNode 列表用来记录该节点所连的子节点。因此我们可以先遍历图里的所有节点，再分别遍历节点里面的 ChildNode，将每一个子节点的输入端口与父节点对应的输出端口相连就可以了。我们打开 GraphView 脚本，增加以下代码：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 链接两个点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;_outputPort&quot;&gt;outputPort&lt;/param&gt;
        /// &lt;param name=&quot;_inputPort&quot;&gt;inputPort&lt;/param&gt;
        private void AddEdgeByPorts(Port _outputPort, Port _inputPort)
        &#123;
            //虽然是不可能发生，但还是保守一点
            if (_outputPort.node == _inputPort.node)
            &#123;
                return;
            &#125;

            Edge tempEdge = new Edge()
            &#123;
                input = _inputPort,
                output = _outputPort
            &#125;;
            tempEdge.input.Connect(tempEdge);
            tempEdge.output.Connect(tempEdge);
            Add(tempEdge);
        &#125;

        /// &lt;summary&gt;
        /// 恢复节点连线
        /// &lt;/summary&gt;
        private void RecoveryEdge(DialogNodeDataBase DialogNodeData)
        &#123;
            if (DialogNodeData.ChildNode == null)
            &#123;
                return;
            &#125;

            for (int i = 0; i &lt; DialogNodeData.ChildNode.Count; i++)
            &#123;
                //没连就跳过
                if (DialogNodeData.ChildNode[i] == null)
                &#123;
                    continue;
                &#125;

                Port _output = NodeDirt[DialogNodeData].outputContainer[i].Q&lt;Port&gt;();
                Port _input = NodeDirt[DialogNodeData.ChildNode[i]].inputContainer[0].Q&lt;Port&gt;();

                AddEdgeByPorts(_output, _input);
            &#125;
        &#125;
</code></pre><p>上面代码我们添加了连接两个 Port 的函数，用的是 Unity 提供的 API，很简单。接下来我们添加了一个能根据 DialogNodeDataBase 对象，遍历其子节点并复原连线的函数。由于我们的连接操作是在 View 层的事情，我们需要持有根据 DialogNodeDataBase 对象所创建的 NodeViewBase 对象。为了避免耦合，且我们的复原操作仅在 DialogTree 打开时进行一次，所以这里我们使用了一个临时的字典来缓存对象间互相持有的关系。字典的填充在复原节点的时候进行，我们修改 RecoveryNode 函数，在函数末尾加入以下代码：</p><pre><code class="language-C#">		NodeDirt.Add(DialogNodeData, nodeView);
</code></pre><p>现在，节点图的连线部分也完成了，我们来做最后的收尾工作。我们将在 GraphView 脚本中创建一个静态变量，用于实现简单的单例模式。代码如下：</p><pre><code class="language-C#">        public static DialogGraphView Instance;

        public DialogGraphView()
        &#123;
            //以上代码省略，在DialogGraphView末尾添加下面代码即可

            //简单的单例模式
            Instance = this;
        &#125;
</code></pre><p>修改 ResetNodeView 方法，增加复原节点连线的逻辑，代码如下：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 重置节点图
        /// &lt;/summary&gt;
        public void ResetNodeView()
        &#123;
            if (treeData != null)
            &#123;
                //初始化字典
                NodeDirt = new Dictionary&lt;DialogNodeDataBase, NodeViewBase&gt;();
                var nodeData = treeData.ChildNodeDataList;

                //检查StartNode是否存在
                if (treeData.StartNodeData == null)
                &#123;
                    CreateNode(NodeType.Start);
                &#125;
                else
                &#123;
                    RecoveryNode(treeData.StartNodeData);
                &#125;

                //恢复节点
                foreach (var node in nodeData)
                &#123;
                    RecoveryNode(node);
                &#125;

                //恢复节点边
                RecoveryEdge(treeData.StartNodeData);
                foreach (var node in nodeData)
                &#123;
                    RecoveryEdge(node);
                &#125;

                //清除字典
                NodeDirt.Clear();
            &#125;
        &#125;

</code></pre><p>现在我们打开 DialogGraphWindow 脚本，在末尾调用 ResetNodeView () 方法。代码如下：</p><pre><code class="language-C#">        public void CreateGUI()
        &#123;
            var visualTree =
                AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(
                    &quot;Assets/DialogueSystem/NodeEditor/EditorWindow/DialogGraphWindow.uxml&quot;);
            visualTree.CloneTree(rootVisualElement);

            _graphView = rootVisualElement.Q&lt;DialogGraphView&gt;(&quot;DialogGraphView&quot;);

            _inspectorView = rootVisualElement.Q&lt;InspectorView&gt;(&quot;InspectorView&quot;);

            var saveButton = rootVisualElement.Q&lt;ToolbarButton&gt;(&quot;SaveButton&quot;);
            saveButton.clicked += OnSaveButtonClicked;

            //初始化节点图
            DialogGraphView.Instance.ResetNodeView();
        &#125;
</code></pre><p>现在我们打开 DialogTree，可以看到，节点图完美复原。到此，我们完成了一个基本的对话系统节点编辑器。但现在我们只有 Start 跟 End 两个节点，这显然还不能算是一个对话系统。所以接下来，我们要做的就是拓展更多节点，完善我们的对话系统 。</p><h2 id="拓展更多节点"><a class="anchor" href="#拓展更多节点">#</a> 拓展更多节点</h2><p>在前面的代码实现中，我们已经实现了一个节点 View 层与 Data 层的基类，NodeViewBase 与 DialogNodeDataBase。那么对于拓展节点，无非就是继承这两个类，并实现不同节点特有的功能而已。</p><p>所以现在我们来规划一下要实现的节点，本次我们先拓展两个基础的对话系统节点：</p><ul><li>顺序对话节点：能够按照从上到下的顺序输出节点内的对话语句</li><li>随机对话节点：能从节点内对话数据中随机选出一句进行输出。</li></ul><p>我们打开 NodeType 枚举，增加新的节点类型，代码如下：</p><pre><code class="language-C#">    public enum NodeType
    &#123;
        Start,
        RandomDialogNode,
        SequentialDialogNode,
        End,
    &#125;
</code></pre><p>首先我们来拓展顺序对话节点：<br>Data 层：<br>新建一个 SequentialDialogNodeData 脚本，代码如下：</p><pre><code class="language-C#">namespace DialogueSystem
&#123;
    public class SequentialDialogNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.SequentialDialogNode;
    &#125;
&#125;
</code></pre><p>View 层：<br>新建一个 SequentialDialogNodeView 脚本，代码如下：</p><pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace DialogueSystem
&#123;
    public class SequentialDialogNodeView : NodeViewBase
    &#123;
        private int nextIndex = 0;
        public SequentialDialogNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;SequentialDialogNode&quot;;
            
            Port input = GetPortForNode(this, Direction.Input, Port.Capacity.Multi);
            Port output = GetPortForNode(this, Direction.Output, Port.Capacity.Single);
            input.portName = &quot;Input&quot;;
            input.portColor = Color.yellow;
            output.portName = &quot;Output&quot;;
            output.portColor = Color.yellow;
            output.name = &quot;0&quot;;
            
            inputContainer.Add(input);
            outputContainer.Add(output);
            
            //工具条
            Toolbar toolbar = new Toolbar();
            ToolbarButton addButton = new ToolbarButton(AddTextField)
            &#123;
                text = &quot;Add&quot;
            &#125;;
            ToolbarButton delButton = new ToolbarButton(DeleteTextField)
            &#123;
                text = &quot;Del&quot;
            &#125;;
            toolbar.Add(addButton);
            toolbar.Add(delButton);
            
            toolbar.style.flexDirection = FlexDirection.RowReverse;
            contentContainer.Add(toolbar);
            
            while (nextIndex &lt; DialogNodeData.OutputItems.Count)
            &#123;
                AddTextField();
            &#125;
            
            if (DialogNodeData.ChildNode.Count &lt; 1)
            &#123;
                DialogNodeData.ChildNode.Add(null);
            &#125;
        &#125;
        
        public void AddTextField()
        &#123;
            if (DialogNodeData.OutputItems.Count &lt; nextIndex + 1)
            &#123;
                DialogNodeData.OutputItems.Add(default);
            &#125;

			//拿了个没有功能的按键当背景，这个按键并没有什么实质性的功能哈哈
            Button background = new Button();

            TextField textField = new TextField();
            textField.name = nextIndex.ToString();
            textField.style.minWidth = 160;
            //初始化
            textField.SetValueWithoutNotify(DialogNodeData.OutputItems[nextIndex]);

            textField.RegisterValueChangedCallback(evt =&gt;
            &#123;
                if (int.TryParse(textField.name, out int index))
                &#123;
                    DialogNodeData.OutputItems[index] = evt.newValue;
                &#125;
                else
                &#123;
                    Debug.LogError(&quot;textField.name(string) to int fail&quot;);
                &#125;
            &#125;);

            background.Add(textField);
            extensionContainer.Add(background);
            RefreshExpandedState();

            nextIndex++;
        &#125;
        
        public void DeleteTextField()
        &#123;
            if (nextIndex &gt; 0)
            &#123;
                nextIndex--;
                
                DialogNodeData.OutputItems.RemoveAt(DialogNodeData.OutputItems.Count - 1);
                extensionContainer.Remove(extensionContainer[nextIndex]);
            &#125;
        &#125;
    &#125;
&#125;
#endif
</code></pre><p>接下来是随机对话节点：<br>Data 层：<br>新建一个 RandomDialogNodeData 脚本，代码如下：</p><pre><code class="language-C#">namespace DialogueSystem
&#123;
    public class RandomDialogNodeData : DialogNodeDataBase
    &#123;
        public override NodeType NodeType =&gt; NodeType.RandomDialogNode;
    &#125;
&#125;
</code></pre><p>View 层：<br>新建一个 RandomDialogNodeView 脚本，代码如下：</p><pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace DialogueSystem
&#123;
    public class RandomDialogNodeView : NodeViewBase
    &#123;
        private int nextIndex = 0;

        public RandomDialogNodeView(DialogNodeDataBase dialogNodeData) : base(dialogNodeData)
        &#123;
            title = &quot;RandomDialogNode&quot;;

            Port input = GetPortForNode(this, Direction.Input, Port.Capacity.Multi);
            Port output = GetPortForNode(this, Direction.Output, Port.Capacity.Single);
            input.portName = &quot;Input&quot;;
            input.portColor = Color.magenta;
            output.portName = &quot;Output&quot;;
            output.portColor = Color.magenta;
            output.name = &quot;0&quot;;

            inputContainer.Add(input);
            outputContainer.Add(output);
            
            //工具条
            Toolbar toolbar = new Toolbar();
            ToolbarButton addButton = new ToolbarButton(AddTextField)
            &#123;
                text = &quot;Add&quot;
            &#125;;
            ToolbarButton delButton = new ToolbarButton(DeleteTextField)
            &#123;
                text = &quot;Del&quot;
            &#125;;
            toolbar.Add(addButton);
            toolbar.Add(delButton);
            
            toolbar.style.flexDirection = FlexDirection.RowReverse;
            contentContainer.Add(toolbar);

            while (nextIndex &lt; DialogNodeData.OutputItems.Count)
            &#123;
                AddTextField();
            &#125;
            
            //加个判断，不然每开一次创一个
            if (DialogNodeData.ChildNode.Count &lt; 1)
            &#123;
                DialogNodeData.ChildNode.Add(null);
            &#125;
        &#125;
        
        public void AddTextField()
        &#123;
            if (DialogNodeData.OutputItems.Count &lt; nextIndex + 1)
            &#123;
                DialogNodeData.OutputItems.Add(default);
            &#125;

			//拿了个没有功能的按键当背景，这个按键并没有什么实质性的功能哈哈
            Button background = new Button();

            TextField textField = new TextField();
            textField.name = nextIndex.ToString();
            textField.style.minWidth = 160;
            //初始化
            textField.SetValueWithoutNotify(DialogNodeData.OutputItems[nextIndex]);

            textField.RegisterValueChangedCallback(evt =&gt;
            &#123;
                if (int.TryParse(textField.name, out int index))
                &#123;
                    DialogNodeData.OutputItems[index] = evt.newValue;
                &#125;
                else
                &#123;
                    Debug.LogError(&quot;textField.name(string) to int fail&quot;);
                &#125;
            &#125;);

            background.Add(textField);
            extensionContainer.Add(background);
            RefreshExpandedState();

            nextIndex++;
        &#125;
        
        public void DeleteTextField()
        &#123;
            if (nextIndex &gt; 0)
            &#123;
                nextIndex--;
                
                DialogNodeData.OutputItems.RemoveAt(DialogNodeData.OutputItems.Count - 1);
                extensionContainer.Remove(extensionContainer[nextIndex]);
            &#125;
        &#125;
    &#125;
&#125;
#endif
</code></pre><p>完成之后，我们打开 GraphView 脚本，编辑 CreateNode、RecoveryNode 方法，使节点能够在 GraphView 中创建，代码如下：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 新建节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
        private void CreateNode(NodeType type, Vector2 position = default)
        &#123;
            if (treeData == null)
            &#123;
                return;
            &#125;

            MakeSureTheFolder();
            NodeViewBase nodeView = null;

            //创建节点的核心，新增的节点需要在这里进行创建方式的添加
            switch (type)
            &#123;
                case NodeType.Start:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;StartNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/StartData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new StartNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.RandomDialogNode:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;RandomDialogNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/RandomDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/RandomDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new RandomDialogNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.SequentialDialogNode:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;SequentialDialogNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/SequentialDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/SequentialDialogData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new SequentialDialogNodeView(dialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    var dialogNodeData = ScriptableObject.CreateInstance&lt;EndNodeData&gt;();
                    dialogNodeData.Path =
                        $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;;
                    EditorUtility.SetDirty(dialogNodeData);

                    AssetDatabase.CreateAsset(dialogNodeData,
                        $&quot;Assets/DialogueData/NodeData/EndData[&#123;dialogNodeData.GetInstanceID()&#125;].asset&quot;);

                    nodeView = new EndNodeView(dialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            //添加节点被选择事件
            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(position, nodeView.GetPosition().size));

            //对Start节点做个特判
            if (nodeView.DialogNodeData.NodeType == NodeType.Start)
            &#123;
                treeData.StartNodeData = nodeView.DialogNodeData;
            &#125;
            else
            &#123;
                treeData.ChildNodeDataList.Add(nodeView.DialogNodeData);
            &#125;

            this.AddElement(nodeView);
        &#125;

        /// &lt;summary&gt;
        /// 恢复节点
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;DialogNodeData&quot;&gt;&lt;/param&gt;
        private void RecoveryNode(DialogNodeDataBase DialogNodeData)
        &#123;
            if (DialogNodeData == null)
            &#123;
                return;
            &#125;

            NodeViewBase nodeView = null;
            //恢复节点的核心部分，新增的节点需要在这里进行恢复方式的添加
            switch (DialogNodeData.NodeType)
            &#123;
                case NodeType.Start:
                &#123;
                    nodeView = new StartNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.RandomDialogNode:
                &#123;
                    nodeView = new RandomDialogNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.SequentialDialogNode:
                &#123;
                    nodeView = new SequentialDialogNodeView(DialogNodeData);
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    nodeView = new EndNodeView(DialogNodeData);
                    break;
                &#125;
                default:
                &#123;
                    Debug.LogError(&quot;未找到该类型的节点&quot;);
                    break;
                &#125;
            &#125;

            nodeView.OnNodeSelected = OnNodeSelected;
            nodeView.SetPosition(new Rect(DialogNodeData.Position, nodeView.GetPosition().size));
            NodeDirt.Add(DialogNodeData, nodeView);

            this.AddElement(nodeView);
        &#125;
</code></pre><p>最后，修改右键菜单，代码如下：</p><pre><code class="language-C#">        /// &lt;summary&gt;
        /// 右键菜单
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;
        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        &#123;
            base.BuildContextualMenu(evt);
            Debug.Log(evt.mousePosition);

            //将鼠标世界坐标转为视图本地坐标
            clickPosition = contentViewContainer.WorldToLocal(evt.mousePosition);

            if (treeData.StartNodeData == null)
            &#123;
                evt.menu.AppendAction(&quot;Create StartNode&quot;, x =&gt; &#123; CreateNode(NodeType.Start, clickPosition); &#125;);
            &#125;

            evt.menu.AppendAction(&quot;Create RandomDialogNode&quot;,
                x =&gt; &#123; CreateNode(NodeType.RandomDialogNode, clickPosition); &#125;);
            evt.menu.AppendAction(&quot;Create SequentialDialogNode&quot;,
                x =&gt; CreateNode(NodeType.SequentialDialogNode, clickPosition));
            evt.menu.AppendAction(&quot;Create EndNode&quot;, x =&gt; &#123; CreateNode(NodeType.End, clickPosition); &#125;);
        &#125;
</code></pre><p>现在我们回到 Unity，随便打开一个节点编辑器，创建我们的新节点试试。可以看到，节点正常被创建了出来，并且我们在节点里面编辑数据，节点对应的 DialogNodeDataBase 对象中的数据也会同步编辑。</p><p><img data-src="https://img-blog.csdnimg.cn/b4271061553641b798e980e692290e19.png#pic_center" alt="对话节点图"></p><p>到这里，我们的对话系统的对话数据跟节点编辑器部分就已经完成了。我们完成了两个基本的系统流程节点，还有两个用于对话控制的对话节点。根据我们的系统架构，我们还可以自由拓展出更多的自定义节点，比如选择对话节点，事件节点等等。在编辑器中我们实现了利用节点图来编辑对话数据文件的功能，而在数据文件中我们只让它负责了数据处理的相关逻辑。具体的对话逻辑我们并不是在数据类中实现，这样的设计不仅实现了解耦，还实现了模块化，便于维护、拓展新的节点模块。下一节，我们将实现对话系统的的逻辑处理部分，以及能挂在 Unity GameObject 上的 Mono 对话系统组件。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-05-10 23:39:20" itemprop="dateModified" datetime="2023-05-10T23:39:20+08:00">2023-05-10</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Bigotry0 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Bigotry0 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Bigotry0 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Bigotry0： </strong>Bigotry0 <i class="ic i-at"><em>@</em></i>游戏开发小地方</li><li class="link"><strong>本文链接：</strong> <a href="https://bigotry0.github.io/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/" title="基于GraphView的对话系统设计（一）对话数据与节点编辑器">https://bigotry0.github.io/2023/05/10/基于GraphView的对话系统设计（一）对话数据与节点编辑器/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/10/hello-world/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclj9410cj20zk0m8h12.jpg" title="Hello World"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Hello World</h3></a></div><div class="item right"><a href="/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevgoki5j20zk0m84qp.jpg" title="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>基于GraphView的对话系统设计（二）节点逻辑处理与对话组件</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">对话系统特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">系统实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">编辑器部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E8%8A%82%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">对话节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%9B%BE%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">节点图的保存与解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%9B%B4%E5%A4%9A%E8%8A%82%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">拓展更多节点</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Bigotry0" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Bigotry0</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">3</span> <span class="name">文章</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/05/10/hello-world/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/10/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/" title="基于GraphView的对话系统设计（一）对话数据与节点编辑器">基于GraphView的对话系统设计（一）对话数据与节点编辑器</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" title="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件">基于GraphView的对话系统设计（二）节点逻辑处理与对话组件</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Bigotry0 @ Bigotry0</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/05/10/基于GraphView的对话系统设计（一）对话数据与节点编辑器/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->