<!-- build time:Thu May 11 2023 00:25:08 GMT+0800 (香港标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="游戏开发小地方" href="https://bigotry0.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="游戏开发小地方" href="https://bigotry0.github.io/atom.xml"><link rel="alternate" type="application/json" title="游戏开发小地方" href="https://bigotry0.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://bigotry0.github.io/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/"><title>基于GraphView的对话系统设计（二）节点逻辑处理与对话组件 | Bigotry0 = 游戏开发小地方</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">基于GraphView的对话系统设计（二）节点逻辑处理与对话组件</h1><div class="meta"><span class="item" title="创建时间：2023-05-10 22:49:37"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-10T22:49:37+08:00">2023-05-10</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Bigotry0</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicli3sbvtj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeybxm1pj20zk0m8niv.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://bigotry0.github.io/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Bigotry0"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="游戏开发小地方"></span><div class="body md" itemprop="articleBody"><blockquote><h5 id="在上一节中，我们实现了一个基于GraphView的对话编辑器，并定义了储存对话数据的对话数据。在这一节，我们将继续完善我们的对话系统。在这一节，我们将完成："><a href="#在上一节中，我们实现了一个基于GraphView的对话编辑器，并定义了储存对话数据的对话数据。在这一节，我们将继续完善我们的对话系统。在这一节，我们将完成：" class="headerlink" title="在上一节中，我们实现了一个基于GraphView的对话编辑器，并定义了储存对话数据的对话数据。在这一节，我们将继续完善我们的对话系统。在这一节，我们将完成："></a>在上一节中，我们实现了一个基于GraphView的对话编辑器，并定义了储存对话数据的对话数据。在这一节，我们将继续完善我们的对话系统。在这一节，我们将完成：</h5><ul><li>对话数据文件的解析与处理</li><li>对话节点逻辑的实现</li><li>用于创建可挂载在Gameobject的Mono脚本基类</li><li>继承基类并创建一个简单的打字机效果对话系统</li></ul></blockquote><h2 id="创建对话系统基类"><a href="#创建对话系统基类" class="headerlink" title="创建对话系统基类"></a>创建对话系统基类</h2><h3 id="定义系统状态"><a href="#定义系统状态" class="headerlink" title="定义系统状态"></a>定义系统状态</h3><p>在编写脚本之前，我们先来讨论一下对话系统的状态。在一个对话系统中，我们可以将其分为三个状态，分别是对话未开始、对话中、对话结束，这是对话系统的系统状态。如图：</p><pre><code class="mermaid">flowchart 
    C[DialogueStates\n对话系统状态] --&gt;D[NotStart\n未开始]
    C --&gt;E[Started\n对话中]
    C --&gt;F[Finished\n已完成]
</code></pre><p>而在进行对话的时候，我们会有自定义语句打印效果或逻辑控制的需求，比如我们后面会实现的打字机效果。为了在对话播放时能够更加细致的进行控制，我们可以定义一个对话语句播放状态，状态包含了播放中、播放完成两个子状态。如下图：</p><pre><code class="mermaid">flowchart 
    C[PlayTextStates\n语句播放状态] --&gt;D[IsPlayed\n播放中]
    C --&gt;F[Finished\n播放完成]
</code></pre><p>有了上图，我们新建一个C#脚本 ，把他命名为DialogSystem.cs，打开脚本，我们首先来定义我们的状态枚举类，代码如下：</p><pre><code class="C#">#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace DialogueSystem
&#123;
    /// &lt;summary&gt;
    /// 对话系统抽象类
    /// &lt;/summary&gt;
    public abstract class DialogueSystem : MonoBehaviour
    &#123;
        /// &lt;summary&gt;
        /// 对话系统状态
        /// &lt;/summary&gt;
        public enum DialogueStates
        &#123;
            /// &lt;summary&gt;
            /// 未开始
            /// &lt;/summary&gt;
            NotStart,

            /// &lt;summary&gt;
            /// 对话中
            /// &lt;/summary&gt;
            Started,

            /// &lt;summary&gt;
            /// 已完成
            /// &lt;/summary&gt;
            Finished
        &#125;

        /// &lt;summary&gt;
        /// 语句播放状态
        /// &lt;/summary&gt;
        public enum PlayTextStates
        &#123;
            /// &lt;summary&gt;
            /// 播放中
            /// &lt;/summary&gt;
            IsPlayed,

            /// &lt;summary&gt;
            /// 播放完成
            /// &lt;/summary&gt;
            Finished
        &#125;

        /// &lt;summary&gt;
        /// 对话系统当前状态
        /// &lt;/summary&gt;
        private DialogueStates DialogueState = DialogueStates.NotStart;

        /// &lt;summary&gt;
        /// 当前语句播放状态
        /// &lt;/summary&gt;
        protected PlayTextStates PlayTextState = PlayTextStates.Finished;
    &#125;
&#125;
</code></pre><p>定义完状态枚举类，我们接着定义几个UnityEvent，用于在状态更新时对外发出通知，可以用来进行UI的更新配置等。代码如下：</p><pre><code>        /// &lt;summary&gt;
        /// NotStart状态回调
        /// &lt;/summary&gt;
        public UnityEvent OnNotStart = new UnityEvent();

        /// &lt;summary&gt;
        /// Started状态回调
        /// &lt;/summary&gt;
        public UnityEvent OnDialogueStart = new UnityEvent();

        /// &lt;summary&gt;
        /// Finished状态回调
        /// &lt;/summary&gt;
        public UnityEvent OnDialogueFinish = new UnityEvent();
</code></pre><p>这样，我们就成功定义了系统的基本状态。</p><h3 id="对话数据的初始化"><a href="#对话数据的初始化" class="headerlink" title="对话数据的初始化"></a>对话数据的初始化</h3><p>我们已经在编辑器里完成了对话数据的创建与编辑，接下来最重要的无非就是怎么去用这些对话数据了。我们的对话数据都是一个个的Scriptableobject对象，所以我们可以直接在脚本中创建一个DialogTree类型的字段，直接引用我们项目中保存的DialogTree对象即可。代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 对话数据
        /// &lt;/summary&gt;
        public DialogTree DialogTree;
</code></pre><p>在Unity中创建一个空的Gameobject，将DialogSystem脚本挂上去，将一个DialogTree文件挂载上去，这样就完成了对DialogTree对象的引用了。有了DialogTree对象，我们可以在脚本中读取里面的节点信息了，打开DialogSystem脚本，添加代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// TreeData是否读取结束
        /// &lt;/summary&gt;
        private bool IsLoadDialogTreeDataEnd = false;

        /// &lt;summary&gt;
        /// 当前对话节点
        /// &lt;/summary&gt;
        private DialogNodeDataBase CurrentDialogNode;

        /// &lt;summary&gt;
        /// 初始化对话树数据
        /// &lt;/summary&gt;
        private void InitDialogTreeData()
        &#123;
            if (DialogTree.StartNodeData == null)
            &#123;
                Debug.LogError(&quot;The Start node does not exist in the DialogTree file&quot;);
                return;
            &#125;

            //StartNode只有一个接口
            CurrentDialogNode = DialogTree.StartNodeData.ChildNode[0];
            IsLoadDialogTreeDataEnd = false;
        &#125;
</code></pre><p>上面的代码创建了一个currentDialogNode变量，用来储存我们当前正要读取的节点。并且我们定义了一个用于初始化读取的方法InitDialogTreeData()，该方法读取对话树文件中的StartNode对象，并将其设置给currentDialogNode，即当前待读取的节点。到此，对话系统对数据的初始化完成。</p><h3 id="对话数据的处理"><a href="#对话数据的处理" class="headerlink" title="对话数据的处理"></a>对话数据的处理</h3><p>对话系统的核心，其实就是是维护一个字符串队列。而输出对话内容，其实就是使字符串数据从这个队列里出列。我们打开DialogSystem脚本，添加以下代码：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 对话数据队列
        /// &lt;/summary&gt;
        public Queue&lt;string&gt; SentenceQueue;

        /// &lt;summary&gt;
        /// 开启对话系统方法
        /// &lt;/summary&gt;
        public void StartDialogue()
        &#123;
            if (DialogueState == DialogueStates.NotStart)
            &#123;
                if (DialogTree == null)
                &#123;
                    Debug.LogError(&quot;The DialogTree file is missing&quot;);
                    return;
                &#125;

                DialogueState = DialogueStates.Started;
                OnDialogueStart?.Invoke();

                //先播放第一句
                Next();
            &#125;
        &#125;

        /// &lt;summary&gt;
        /// 继续对话方法
        /// &lt;/summary&gt;
        public void Next()
        &#123;
            if (DialogueState != DialogueStates.Started)
            &#123;
                return;
            &#125;

            if (IsSelecting)
            &#123;
                return;
            &#125;

            if (SentenceQueue.Count &gt; 0)
            &#123;
                switch (PlayTextState)
                &#123;
                    case PlayTextStates.Finished:
                    &#123;
                        // 用来输出文本的抽象方法，后面会讲
                        PlayText(SentenceQueue.Dequeue());
                        break;
                    &#125;

                    case PlayTextStates.IsPlayed:
                    &#123;
                        // 在对话语句播放期间调用Next方法时调用，该方法为抽象方法，后面会讲
                        NextOnTextIsPlayed();
                        break;
                    &#125;
                &#125;
            &#125;
            else
            &#123;
                //加载当前节点
                LoadCurrentDialogNode();
                
                if (IsLoadDialogTreeDataEnd)
                &#123;
                    DialogueState = DialogueStates.Finished;
                    OnDialogueFinish?.Invoke();
                &#125;
                else
                &#123;
                    //递归
                    Next();
                &#125;
            &#125;
        &#125;
</code></pre><p>在上面的代码中，我们对外提供了几个方法，用于操作对话系统。其中在Next方法中，对话数据的读取是一个递归的过程。当对话队列里对象为空，且当前对话节点未进行至EndNode时，程序会读取当前待读取的节点。读取节点用到了一个LoadCurrentDialogNode方法，我们就来实现他。代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 加载当前对话节点
        /// &lt;/summary&gt;
        private void LoadCurrentDialogNode()
        &#123;
            if (IsLoadDialogTreeDataEnd)
            &#123;
                return;
            &#125;

            if (CurrentDialogNode == null)
            &#123;
                Debug.LogError(&quot;The branch has ended but the EndNode is not connected&quot;);
                //保护措施
                IsLoadDialogTreeDataEnd = true;
                return;
            &#125;

            // 检测节点类型，并进行对应处理
            switch (CurrentDialogNode.NodeType)
            &#123;
                case NodeType.SequentialDialogNode:
                &#123;
                    // todo
                    break;
                &#125;
                case NodeType.RandomDialogNode:
                &#123;
                    // todo
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    // todo
                    break;
                &#125;
            &#125;
        &#125;
</code></pre><p>在LoadCurrentDialogNode方法中，对于任意的节点，我们首先检测节点的类型，得到节点类型后，我们就可以根据不同的类型，对节点进行不同的处理。</p><p>这样，我们任何一个节点，都由这三部分构成，储存数据的Data，负责UI的View，还有负责各节点逻辑的LoadCurrentDialogNode方法。这种架构有点类似MVC架构。在架构的帮助下，我们不仅可以快速拓展新的节点，而且对象间的耦合度低。我们来完成节点的具体逻辑，完善LoadCurrentDialogNode方法，代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 加载当前对话节点
        /// &lt;/summary&gt;
        private void LoadCurrentDialogNode()
        &#123;
            if (IsLoadDialogTreeDataEnd)
            &#123;
                return;
            &#125;

            if (CurrentDialogNode == null)
            &#123;
                Debug.LogError(&quot;The branch has ended but the EndNode is not connected&quot;);
                //保护措施
                IsLoadDialogTreeDataEnd = true;
                return;
            &#125;

            switch (CurrentDialogNode.NodeType)
            &#123;
                case NodeType.SequentialDialogNode:
                &#123;
                    foreach (var output in CurrentDialogNode.OutputItems)
                    &#123;
                        // 按顺序全部入列
                        SentenceQueue.Enqueue(output);
                    &#125;

                    // 设置下一个待读取节点
                    CurrentDialogNode = CurrentDialogNode.ChildNode[0];
                    break;
                &#125;
                case NodeType.RandomDialogNode:
                &#123;
                    if (CurrentDialogNode.OutputItems.Count &gt; 0)
                    &#123;
                        // 选择一个随机语句入列
                        SentenceQueue.Enqueue(
                            CurrentDialogNode.OutputItems[Random.Range(0, CurrentDialogNode.OutputItems.Count)]);
                    &#125;

                    CurrentDialogNode = CurrentDialogNode.ChildNode[0];
                    break;
                &#125;
                case NodeType.End:
                &#123;
                    // 结束
                    IsLoadDialogTreeDataEnd = true;
                    break;
                &#125;
            &#125;
        &#125;
</code></pre><p>完成了节点的逻辑部分，我们也差不多该收尾了，继续编辑DialogueSystem脚本，对外提供一个重置对话的方法，并在脚本Awake的时候调用一下。代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 重置对话方法
        /// &lt;/summary&gt;
        public void Reset()
        &#123;
            SentenceQueue = new Queue&lt;string&gt;();
            DialogueState = DialogueStates.NotStart;
            IsLoadDialogTreeDataEnd = false;

            OnNotStart?.Invoke();

            InitDialogTreeData();
        &#125;

        void Awake()
        &#123;
            //初始化
            Reset();
        &#125;
</code></pre><p>到这，对话系统的处理就完成了。接下来，是对话系统的对话输出部分。</p><h3 id="对话进行"><a href="#对话进行" class="headerlink" title="对话进行"></a>对话进行</h3><p>做完了对话数据的处理，我们是时候让对话系统跑起来了。作为一个对话系统，我们肯定要能够输出对话，那么，如何输出对话就是我们接下来要解决的问题。</p><p>在输出对话的时候，我们可能会有不同的输出需求，如逐字输出啊、实时对对话进行一些处理等。而且，我们的对话文本也并非只能以固定的方式进行输出。为了实现这一点，我们将字符串输出做成一个事件，代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 用于设置文本输出目标
        /// &lt;/summary&gt;
        public UnityEvent&lt;string&gt; OnPlayText = new UnityEvent&lt;string&gt;();

        /// &lt;summary&gt;
        /// 播放对话语句方法，该方法在子类中实现，可自定义语句打印效果
        /// 子类必须在打印语句时将PlayTextState设置为IsPlayed状态，打印完成时必须将其设置为Finished状态
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sentence&quot;&gt;当前对话语句&lt;/param&gt;
        protected abstract void PlayText(string sentence);

        /// &lt;summary&gt;
        /// 状态监听方法，该方法在子类中实现，该方法在PlayTextState为IsPlayed时尝试继续对话时被调用，可在子类中监听并进行处理
        /// &lt;/summary&gt;
        protected abstract void NextOnTextIsPlayed();

        /// &lt;summary&gt;
        /// 对外输出语句方法
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;文本&lt;/param&gt;
        protected void OutputText(string text)
        &#123;
            if (text == null)
            &#123;
                return;
            &#125;
            
            OnPlayText?.Invoke(text);
        &#125;
</code></pre><p>创建事件的同时，我们也定义了两个抽象方法，PlayText跟NextOnTextIsPlayed。这两个方法要求在子类中实现，其中PlayText方法会在打印对话语句时调用，NextOnTextIsPlayed则是在对话播放还尚未结束的时候调用Next方法时会被调用。</p><p>利用这两个抽象方法，我们能对对话播放进行细致的自定义操作。另外我们也封装了一个用于对外发送输出文本事件的函数，该函数主要还是用于在对话系统类中使用。</p><p>到此，我们的对话系统基类的雏形就完成了，以后只要继承该类，就能快速根据自己需求拓展出不同的对话组件。</p><h2 id="利用对话系统基类创建打字机效果对话系统"><a href="#利用对话系统基类创建打字机效果对话系统" class="headerlink" title="利用对话系统基类创建打字机效果对话系统"></a>利用对话系统基类创建打字机效果对话系统</h2><p>要创建一个自定义的对话系统组件，只要继承对话系统抽象类，并实现抽象方法即可。下面，我们以实现一个打字机效果的对话系统为例，演示一下如何自定义我们自己的对话系统类。</p><p>新建一个TypingEffectsDialogue.cs脚本，添加代码如下：</p><pre><code class="C#">using System;
using System.Collections;
using LFramework.Kit.DialogueSystem;
using UnityEngine;

public class TypingEffectsDialogue : DialogueSystem
&#123;
    /// &lt;summary&gt;
    /// 文本打印速度
    /// &lt;/summary&gt;
    public float TypingSpeed;

    /// &lt;summary&gt;
    /// 缓存当前对话文本
    /// &lt;/summary&gt;
    private string CurrentSentence = String.Empty;

    /// &lt;summary&gt;
    /// 缓存对话打印协程
    /// &lt;/summary&gt;
    private Coroutine TextEffectCoroutine;

    protected override void PlayText(string sentence)
    &#123;
        //打印前将对话状态设定为IsPlayed
        PlayTextState = PlayTextStates.IsPlayed;

        CurrentSentence = sentence;
        TextEffectCoroutine = StartCoroutine(StartPlayText());
    &#125;

    /// &lt;summary&gt;
    /// 打字机效果
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private IEnumerator StartPlayText()
    &#123;
        string sentenceToPlay = string.Empty;
        var length = CurrentSentence.Length;

        for (var i = 0; i &lt;= length; i++)
        &#123;
            yield return new WaitForSeconds(TypingSpeed);

            sentenceToPlay = CurrentSentence.Substring(0, i);
            OutputText(sentenceToPlay);
            //OnPlayText?.Invoke(sentenceToPlay);
        &#125;

        //打印完成后将对话状态设定为Finished
        PlayTextState = PlayTextStates.Finished;
    &#125;
&#125;
</code></pre><p>要实现打字机效果，我们可以使用一个协程来完成。在协程中不断循环递增分割目标字符串即可。值得注意点是，在我们执行耗时效果之前，我们应该将语句播放状态设置为播放中（IsPlayed），并在语句播放完成时将状态设置成播放完成（Finished）。这样当语句播放未完成时调用Next方法，系统会自动调用NextOnTextIsPlayed方法。在这里，我们能对玩家的输入行为进行响应，做出相应处理。<br>比如在我们的打字机效果未完成时调用Next方法，我们可以直接跳过效果，输出完整的对话语句。实现NextOnTextIsPlayed抽象方法，代码如下：</p><pre><code class="C#">    protected override void NextOnTextIsPlayed()
    &#123;
        StopCoroutine(TextEffectCoroutine);
        OnPlayText?.Invoke(CurrentSentence);

        //打印完成后将对话状态设定为Finished
        PlayTextState = PlayTextStates.Finished;
    &#125;
</code></pre><p>就像上面的例子，简单的实现对话系统基类提供的抽象方法，我们就能自定义出不同需求的对话组件。下面，我们来演示一下如何利用该组件，快速创建一个运行在游戏中的对话系统。</p><h2 id="使用打字机效果对话系统组件"><a href="#使用打字机效果对话系统组件" class="headerlink" title="使用打字机效果对话系统组件"></a>使用打字机效果对话系统组件</h2><p>首先新建一个空物体，命名为DialogueManager，将我们的TypingEffectsDialogue.cs脚本拖拽到物体上面，可以看到Inspector选项卡里出现的参数，如下图：</p><p><img data-src="https://img-blog.csdnimg.cn/453f40d6183c407288148cb447cc33c3.png#pic_center" alt="对话组件Inspector"><br>首先要配置的是我们的DialogTree对象，选择一个创建编辑好的DialogTree文件，将其拖拽到对话系统图开放的参数中。</p><p><img data-src="https://img-blog.csdnimg.cn/d9ac45f8e0e847cebdcb8f3c01e686bc.png#pic_center" alt="设置对话树文件"><br>对话文件进行了简单的设置，大家可以看看内容：</p><p><img data-src="https://img-blog.csdnimg.cn/8d89f0cbf46741eb9a6256140d98b3a5.png#pic_center" alt="简单的例子"><br>接下来我们来创建的一个简单的对话UI，首先在Canvas里创建一个文本（），再创建3个按钮（Button），分别命名为Start、Next和Reset。UI参考如下：</p><p><img data-src="https://img-blog.csdnimg.cn/b0344386417f41799b0a88ed4028e52c.png#pic_center" alt="UI参考"><br>UI层级：</p><p><img data-src="https://img-blog.csdnimg.cn/c03e2f7619af49b7ad9a910a3f687ff2.png#pic_center" alt="层级"></p><p>创建完UI后，我们来设置各种参数，首先是三个按钮，分别给他们增加一个新的点击事件，分别调用DialogueManager中的StartDialog()、Next()、Reset()方法。</p><p><img data-src="https://img-blog.csdnimg.cn/3796efe7796a4ab08997968271dcbe4d.png#pic_center" alt="Button事件"></p><p>接着点击DialogueManager，可以在面板上看到三个状态事件，我们来配置他们以对UI进行控制。</p><ul><li>在对话未开始（OnNotStart）时，Next、Reset按钮应该处于设置为未激活状态，而Start按钮则应该激活。</li><li>在对话开始（OnStarted）时，Start、Reset按钮应该处于设置为未激活状态，而Next按钮则应该激活。</li><li>在对话结束（OnFinish）时，Start、Next按钮应该处于设置为未激活状态，而Reset按钮则应该激活。</li></ul><p>按照上述逻辑我们设置如下：</p><p><img data-src="https://img-blog.csdnimg.cn/26fb4d85c91148ccb27e51307dea70ac.png#pic_center" alt="对话系统组件"></p><p>配置完了按钮UI逻辑，我们来配置文本输出的UI，查看面板的OnPlayText事件，将我们的Text组件设置进去，目标就是我们Text组件的text参数。如下：<br><img data-src="https://img-blog.csdnimg.cn/798adac4a62d409fbdd1ca44d9e4e02d.png#pic_center" alt="设置Text"></p><p>最后，在OnStarted和OnFinish增加新的事件，在对话开始时激活Text对象，而在对话结束和对话未开始时将其设置为未激活。如下：</p><p><img data-src="https://img-blog.csdnimg.cn/9eb2e5d8399149c6a7f1b6109baff001.png#pic_center" alt="在这里插入图片描述"></p><p>现在，我们运行项目，测试一下对话系统。</p><p><img data-src="https://img-blog.csdnimg.cn/04b092ea0a874b4f9efc848b4a49a90f.gif#pic_center" alt="测试"></p><p>可以看到，对话系统正常运行。</p><h2 id="拓展对话系统加载DialogTree的方式"><a href="#拓展对话系统加载DialogTree的方式" class="headerlink" title="拓展对话系统加载DialogTree的方式"></a>拓展对话系统加载DialogTree的方式</h2><p>现在，我们已经完成了一个可用的简易对话系统，他通过从外部引用DialogTree对象来加载对话数据。但这种方式并不是很灵活，我们可以对外提供一些更加灵活点加载方法，开发更加方便。</p><h3 id="通过文件路径加载"><a href="#通过文件路径加载" class="headerlink" title="通过文件路径加载"></a>通过文件路径加载</h3><p>我们可以提供一个加载方法，利用所传入的相对路径加载DialogTree对象。代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 通过路径设置
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;path&quot;&gt;DialogTree对象相对路径&lt;/param&gt;
        public void SetDialogTree(string path)
        &#123;
            var dialogTree = AssetDatabase.LoadAssetAtPath&lt;DialogTree&gt;(path);
            //var dialogTree = Resources.Load(path);
            if (dialogTree == null)
            &#123;
                Debug.LogError(&quot;Load DialogTree in path:&quot; + path + &quot; failed!&quot;);
                return;
            &#125;

            if (typeof(DialogTree) == DialogTree.GetType())
            &#123;
                DialogTree = dialogTree;
            &#125;

            if (DialogueState != DialogueStates.Started)
            &#123;
                InitDialogTreeData();
            &#125;
        &#125;
</code></pre><h3 id="直接通过DialogTree对象进行加载"><a href="#直接通过DialogTree对象进行加载" class="headerlink" title="直接通过DialogTree对象进行加载"></a>直接通过DialogTree对象进行加载</h3><p>提供一个加载方法，直接将所传入的DialogTree对象加载到对话系统中。代码如下：</p><pre><code class="C#">        /// &lt;summary&gt;
        /// 通过对象设置
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dialogTree&quot;&gt;DialogTree对象&lt;/param&gt;
        public void SetDialogTree(DialogTree dialogTree)
        &#123;
            if (dialogTree == null)
            &#123;
                Debug.LogError($&quot;The DialogTree: &#123;dialogTree&#125; object is Null&quot;);
                return;
            &#125;

            DialogTree = dialogTree;
            
            if (DialogueState != DialogueStates.Started)
            &#123;
                InitDialogTreeData();
            &#125;
        &#125;
</code></pre><p>通过以上的方式，我们能更加灵活的在开发中使用最符合项目实际情况的加载方式，当然我们也能继续增加新的加载方式，大家可以根据需求继续拓展。比如后续我们打算引入的仓库模式用来管理对话数据，这部分就留着以后的章节有机会再讨论了。</p><p>到此，本章节也进入了尾声。在本章节中，我们实现了对话数据的解析和对话节点的逻辑处理。到这时，我们总算是形成了节点对话系统的完整架构，即Data、View与Controller层。Data层负责节点数据的存储，View层负责节点在编辑器中的表现，而Controller层则是对节点在运行期间的逻辑进行控制。该架构其实很类似MVC架构，不过在此之上我们还有对编辑器与非编辑器部分进行了分层，这部分可以查看一下上一节文章。</p><p>总之，我们得到了一个非常易于拓展的对话系统，对于任意一个新的节点，我们只要分别考虑并实现他们的三个层，就能拓展出一个新的节点，后面我们会拓展更多的节点，例如分支选择对话节点，角色切换节点，事件节点，同时对话节点等等。但在此之前，现阶段我们的对话节点在资源管理方面还是存在很多的问题，比如节点数据不会在对话树删除后自动处理等，我们将在下一章来完善这些功能。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-05-10 22:55:29" itemprop="dateModified" datetime="2023-05-10T22:55:29+08:00">2023-05-10</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Bigotry0 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Bigotry0 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Bigotry0 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Bigotry0： </strong>Bigotry0 <i class="ic i-at"><em>@</em></i>游戏开发小地方</li><li class="link"><strong>本文链接：</strong> <a href="https://bigotry0.github.io/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" title="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件">https://bigotry0.github.io/2023/05/10/基于GraphView的对话系统设计（二）节点逻辑处理与对话组件/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciuv0socj20zk0m8qes.jpg" title="基于GraphView的对话系统设计（一）对话数据与节点编辑器"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>基于GraphView的对话系统设计（一）对话数据与节点编辑器</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8A%E4%B8%80%E8%8A%82%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8C%E5%B9%B6%E5%AE%9A%E4%B9%89%E4%BA%86%E5%82%A8%E5%AD%98%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E3%80%82%E5%9C%A8%E8%BF%99%E4%B8%80%E8%8A%82%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%E7%BB%A7%E7%BB%AD%E5%AE%8C%E5%96%84%E6%88%91%E4%BB%AC%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E3%80%82%E5%9C%A8%E8%BF%99%E4%B8%80%E8%8A%82%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%E5%AE%8C%E6%88%90%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">在上一节中，我们实现了一个基于GraphView的对话编辑器，并定义了储存对话数据的对话数据。在这一节，我们将继续完善我们的对话系统。在这一节，我们将完成：</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">创建对话系统基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81"><span class="toc-number"></span> <span class="toc-text">定义系统状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">对话数据的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number"></span> <span class="toc-text">对话数据的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E8%BF%9B%E8%A1%8C"><span class="toc-number"></span> <span class="toc-text">对话进行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F"><span class="toc-number"></span> <span class="toc-text">利用对话系统基类创建打字机效果对话系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">使用打字机效果对话系统组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BDDialogTree%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">拓展对话系统加载DialogTree的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%8A%A0%E8%BD%BD"><span class="toc-number"></span> <span class="toc-text">通过文件路径加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87DialogTree%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD"><span class="toc-number"></span> <span class="toc-text">直接通过DialogTree对象进行加载</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Bigotry0" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Bigotry0</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">3</span> <span class="name">文章</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/10/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%BB%84%E4%BB%B6/" title="基于GraphView的对话系统设计（二）节点逻辑处理与对话组件">基于GraphView的对话系统设计（二）节点逻辑处理与对话组件</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/10/%E5%9F%BA%E4%BA%8EGraphView%E7%9A%84%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8/" title="基于GraphView的对话系统设计（一）对话数据与节点编辑器">基于GraphView的对话系统设计（一）对话数据与节点编辑器</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Bigotry0 @ Bigotry0</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/05/10/基于GraphView的对话系统设计（二）节点逻辑处理与对话组件/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->